{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nskit","text":"<p><code>nskit</code> is a python package that provides useful utilities and implementations for creating and managing a namespaced codebase for python and other programming languages.</p> <p>It includes:</p> <ul> <li>nskit.mixer provides a jinja2 based composable template system that can be adapted to any programming language</li> <li>nskit.recipes provides some initial recipes for repositories (using nskit.mixer), including:<ul> <li><code>python_package</code> - a python package including namespace structures</li> <li><code>python_api_service</code> - a python api service including namespace structures</li> <li><code>recipe</code> - a recipe for creating a new recipe</li> </ul> </li> <li>nskit.vcs providing some simple interfaces for working with a Version Control System, and creating/managing repositories, cloning the code base etc.</li> </ul> <p>Find out how to use it here</p>"},{"location":"changelog/","title":"Releases","text":""},{"location":"changelog/#011","title":"0.1.1","text":"<p>Released at 2023-12-27T12:21:54+00:00 </p>"},{"location":"changelog/#changes","title":"Changes","text":""},{"location":"changelog/#features","title":"\ud83d\ude80 Features","text":"<p>- Adding docs plugins <code>mkdocs_licenseinfo</code> and <code>mkdocs_github_changelog</code>  to documentation @djpugh (#25)\r \r</p>"},{"location":"changelog/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<p>- Fixing description type @djpugh (#24)\r - Fixing cicd publish @djpugh (#22)\r - Fixing sonar @djpugh (#23) </p>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Released at 2023-12-24T10:10:45+00:00  \ud83c\udf81 Initial release of <code>nskit</code> \ud83c\udf81\r \r</p>"},{"location":"changelog/#features_1","title":"\ud83d\ude80 Features","text":"<p>- common components for working in the framework\r - recipe based functionality for creating recipes (using <code>nskit.mixer</code>)\r - VCS and codebase management utilities (using <code>nskit.vcs</code>)\r - Improved multi-language capabilities @djpugh (#12)\r - Adding documentation including usage examples @djpugh (#7)\r - Adding docs structure to recipes @djpugh (#19)\r - Adding LicenseFile and callable content option for File @djpugh (#15)\r - Extensible Jinja2 Environment Extensions (and Initialisation) @djpugh (#18)\r \r</p>"},{"location":"changelog/#maintenance","title":"\ud83e\uddf0 Maintenance","text":"<p>- Update tj-actions/changed-files action to v41 @renovate (#20)\r - Adding ci/cd checks and pipelines @djpugh (#13)\r - Update actions/download-artifact action to v4 @renovate (#10)\r - Update github/codeql-action action to v3 @renovate (#9)\r - Update actions/upload-artifact action to v4 @renovate (#11)\r - Update actions/setup-python action to v5 @renovate (#8)\r - Update fossa-contrib/fossa-action action to v3 @renovate (#6)\r </p>"},{"location":"usage/","title":"Using NSKit","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Installation is as simple as: <pre><code>pip install nskit\n</code></pre> It requires a Python version after 3.8+</p>"},{"location":"usage/#optional-dependencies","title":"Optional dependencies","text":"<p>nskit has optional dependencies for different VCS systems:</p> <ul> <li>Github - add <code>ghapi</code> or use <code>pip install nskit[github]</code></li> <li>Azure Devops - add <code>azure-cli</code> or use <code>pip install nskit[azure_devops]</code></li> </ul>"},{"location":"usage/#simple-usage","title":"Simple Usage","text":"<p><code>nskit</code> is designed to be used for two main use cases, creating repositories from repository recipes, and managing codebase repositories in a version control system.</p>"},{"location":"usage/#creating-a-repo-from-a-recipe","title":"Creating a repo from a recipe","text":"<p>Recipes are the combination of ingredients (e.g. nskit.recipes.python.ingredients) that are put together to create a template repository that can have contextual information added.</p> <p>It uses jinja2 to provide the template information.</p> <p>There are 3 recipes provided through <code>nskit</code>:</p> <ul> <li>recipe for creating new recipes</li> <li>python_package for python packages</li> <li>python_api_service for python fastapi based  API services</li> </ul> <p>A Recipe can be loaded and instantiated using the base nskit.mixer.Recipe class <pre><code>from nskit.mixer import Recipe\n# kwargs are the context variables\n# You can see the required and available fields/objects using\n# print(Recipe.inspect(\u2018python_package))\n# In this case, they are:\n\n&lt;Signature (*,\n  name: str = \u2018my_package\u2019,\n  repo: nskit.recipes.python.PyRepoMetadata = &lt;Signature (*\n    repo_separator: str = '-',\n    owner: str,\n    email:str,\n    description: str = '',\n    url: ...) -&gt; nskit.recipes.python.PyRepoMetadata&gt;,\n  git: nskit.mixer.repo.GitConfig = &lt;Signature (*,\n    initial_branch_name: str = 'main',\n    git_flow: bool = True) -&gt; nskit.mixer.repo.GitConfig&gt;,\n  license: Optional[nskit.mixer.components.license_file.LicenseOptionsEnum] = None\n) -&gt; nskit.recipes.pythong.package.PackageRecipe&gt;\n# So to load it you have to specify the following fields\nkwargs = {\n    'repo': {\n        'owner': ...,\n        'email': ...,\n        'url': ...\n    }\n}\n# Although you can obviously override the defaults and set e.g. name, repo.description\nmy_package = Recipe.load(\u2018python_package\u2019, **kwargs)\n</code></pre></p> <p>This uses entry points, specifically the <code>nskit.recipes</code> entrypoint to find other recipes.</p> <p>And then create the recipe object: <pre><code>my_package.create()\n# creates the repository using the local directory as the root\n# e.g. if it is creating a folder my_package it will be in &lt;cwd&gt;/my_package.\n\n#The location and folder name can be customised:\nmy_package.create(base_path=\u2018/path/to/my/root/folder\u2019, override_path=\u2018xyz\u2019)\n# Creates the template at /path/to/my/root/folder/xyz instead of &lt;cwd&gt;/my_package\n# You could also specifically override context parameters at create time as additional kwargs\n</code></pre></p>"},{"location":"usage/#license-files","title":"License Files","text":"<p>The 3 example templates have a license file option, using the nskit.mixer.components.LicenseFile class, which calls the github API to get the license file definitions available on Github. These files will only be created if an appropriate <code>license</code> context variable is passed in (the default is None), so you can override the license with your own specific license in a template as required.</p> <p>The license options are defined in nskit.mixer.components.LicenseOptionsEnum.</p>"},{"location":"usage/#creating-a-codebase","title":"Creating a codebase","text":"<p>The nskit.vcs.Codebase object is used to manage recipes on a remote version control system.</p> <p>The supported providers with <code>nskit</code> are:</p> <ul> <li>Github</li> <li>Azure Devops</li> </ul> <p>More can be added as extensions with the <code>nskit.vcs.providers</code> entry point (see [Extending nskit][]).</p> <p>You need to initialise the codebase at the root folder that you want the codebase to exist under, or override the root_dir parameter.</p> <p>I.e.</p> <p>if you create a Codebase object as <pre><code>c = Codebase()\n</code></pre> It will use the current directory as the root directory.</p> <p>Alternatively, you can specify the root directory <pre><code>c = Codebase(root_dir=Path.cwd().parent)\n</code></pre> To use the parent directory</p> <p>There are other parameters that you can set:</p> <ul> <li><code>settings</code>: the codebase settings, configures the provider to use</li> <li><code>namespaces_dir</code>: the directory (from <code>root_dir</code>) for the namespace constraints to be cloned to - see Using namespaces below</li> <li><code>virtualenv_dir</code>: the directory (from <code>root_dir</code>) for the virtualenv to be created in.</li> <li><code>virtualenv_args</code>: additional args to use for virtual env creation (e.g. azure_devops_artifacts_helpers)</li> </ul> <p>The defaults for these should work, but can also be set via environment variables (or <code>.env</code> files).</p> <p>The settings provide the provider to use. This can be set through environment variables or .env files, and can either be set explicitly (via the <code>vcs_provider</code> settings parameter), or if that is not set, by trying to initialise all available providers to see if one succeeds - the last successful provider will be used.</p> <p>Initialising the provider clients relies on the correct settings for that provider being set.</p>"},{"location":"usage/#for-azure-devops-nskitvcsprovidersazure_devopsazuredevopssettings","title":"For Azure DevOps - nskit.vcs.providers.azure_devops.AzureDevOpsSettings:","text":"<ul> <li><code>organisation</code> - the Azure Devops organisation to use</li> <li><code>project</code> - the Azure Devops project to use</li> </ul> <p>The azure devops url can also be overwritten for e.g private servers, although the associated API functionality is built against the cloud API.</p> <p>These can be set using the following environment variables <code>AZURE_DEVOPS_ORGANISATION</code>, and <code>AZURE_DEVOPS_PROJECT</code>.</p> <p>You may also want to set the <code>NSKIT_PYTHON_INSTALLER_VIRTUALENV_ARGS</code> environment variable to <code>[\"--seeder\",\"azdo-pip\"]</code> to make the created virtualenvironment be seeded with the azure devops authentication helpers. This is using pydantic settings handling, which parses environment variables for complex parameters as a JSON string.</p> <p>Info</p> <p>This uses the <code>azure_devops_artifacts_helpers</code> library.</p>"},{"location":"usage/#for-github-nskitvcsprovidersgithubgithubsettings","title":"For Github - nskit.vcs.providers.github.GithubSettings:","text":"<ul> <li><code>organisation</code> - the Github organisation/user to use</li> <li><code>token</code> - the Github token to use</li> </ul> <p>The github url can also be overwritten for e.g private servers, although the associated API functionality is built against the cloud API.</p> <p>These can be set using the following environment variables <code>GITHUB_ORGANISATION</code>, and <code>GITHUB_TOKEN</code>.</p> <p>There are other parameters that can be set for these providers as well as described in the API</p>"},{"location":"usage/#creating-a-new-repo","title":"Creating a new repo","text":"<p>Once you have created a Codebase object, you can create a new repo using it. <pre><code>c.create_repo('my_new_repo')\n</code></pre></p> <p>This will create the repo in the VCS provider (if it doesn't exist, erroring if it exists remotely or locally), and clone it to the local structure.</p>"},{"location":"usage/#with-a-recipe","title":"With a recipe","text":"<p>To use a recipe, you need to specify the recipe and kwargs in the <code>create_repo</code> call: <pre><code>kwargs = {\n    repo': {\n        'owner': ...,\n        'email': ...,\n        'url': ...\n    }\n}\nc.create_repo('my_new_package', with_recipe='python_package', **kwargs)\n</code></pre> These are the same recipe names and kwargs as used in Creating a repo from a recipe.</p> <p>This will create that repo in the VCS and locally, and then use the recipe to initialise the repo with an intial commit, push it, and install into the virtualenv.</p>"},{"location":"usage/#cloning-the-codebase","title":"Cloning the codebase","text":"<p>You can use the codebase object to clone all the repos (see Using namespaces for how this works with namespaces).</p> <pre><code>c.clone()\n</code></pre> <p>This will clone the repos in the VCS provider to the local directory, and install them into the virtualenv without dependencies, and then run through all the repos to install them with dependencies.</p> <p>This means that you will get a virtualenv with all your codebase dependencies installed as editable installs.</p>"},{"location":"usage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/#creating-new-recipes","title":"Creating new recipes","text":"<p>A key feature from using <code>nskit</code> is the recipes. These can be added based on your personal or organisational needs.</p> <p>The recipe approach is inspired by cookiecutter, but is structured with a bottom up, building blocks, design, which allows easier inheritance and sharing of strutures and components.</p> <p>There is an easy way to create a new recipe, using the recipe recipe.</p> <p>This will create a simple structure with the correct <code>pyproject.toml</code>, including the <code>[project.entry-points.\"nskit.recipes\"]</code> entrypoint section, and some template files.</p> <p>There are 3 key parts to a recipe:</p>"},{"location":"usage/#ingredients","title":"Ingredients","text":"<p>These are the recipe building blocks, intended to be template files and folders (e.g. a <code>docs</code> folder, or a <code>src</code> folder, or a <code>.gitgnore</code> file).</p> <p>These use jinja2 to provide the template information, and are built with two main python classes:</p> <ul> <li>File - has <code>content</code> which is either a <code>jinja2</code> template, callable, or just text, and a <code>name</code>, which is again either a <code>jinja2</code> template, callable or text.</li> <li>Folder - has <code>contents</code> which is either Files, or Folders and a <code>name</code>, which is again either a <code>jinja2</code> template, callable, or text.</li> </ul> <p>The callable options for <code>content</code> and <code>name</code> need to have the signature: <code>def &lt;func&gt;(context: Dict[str, Any]):</code>. An example of these is the methods in nskit.mixer.components.LicenseFile for the name and content (get_license_filename, and get_license_content).</p> <p>These allow the different template blocks to be reused, and adapted.</p> <p>Folder contents can be updated using indexing, either by <code>name</code>, or <code>id_</code> (an additional parameter that can be set on  Files and Folders to allow for indexing), using e.g.: <pre><code>my_folder = Folder(name='my_folder', contents = [\n    File(name='example.md', id_='example', content='123')\n])\nmy_new_file = File(name='example.md', content='Hello world')\n# There are 3 ways to get the file in the folder:\n# By list index\noriginal_file = my_folder.contents[0]\n# By name\noriginal_file = my_folder['example.md']\n# By id\noriginal_file = my_folder['example']\n\n# Each of those three ways can be used to also change it, e.g.\n# my_folder.contents[0] = my_new_file\n# my_folder['example.md'] = my_new_file\nmy_folder['example'] = my_new_file\n\n# Note, because id_ is not set on my_new_file, referencing by the ID won't work now\n</code></pre></p> <p>Warning</p> <p>names and ids are not enorced to be unique, so the first response that matches either id or name is returned. If you anticipate making use of this, please make sure files and ids do not clash</p>"},{"location":"usage/#hooks","title":"Hooks","text":"<p>A Hook is a callable object that can modify things before or after the recipe is created.</p> <p>These are intended for e.g. specific configuration actions, or installing/configuring utilities (e.g. <code>pre-commit</code>).</p> <p>Hooks are easy to create, see for example the code for the [nskit.mixer.hooks.git.GitInit] hook, or for a more simple example: <pre><code>from typing import Any, Dict\nfrom pathlib import Path\n\nfrom nskit.mixer.components import Hook\n\nclass MyHook(Hook):\n\n    def call(self, recipe_path: Path, context: Dict[str, Any]):\n        \"\"\"This is where your hook logic goes\"\"\"\n        # recipe_path is the proposed (if pre_hook) path to create the recipe at,\n        # or current (if post_hook) path the recipe has been created at.\n        #\n        # context is the proposed (if pre_hook) context dictionary to pass to the templates,\n        # or used context dictionary (if post_hook)\n        #\n        print(f'Recipe created at {recipe_path}, with context {context}')\n        # return None\n        # or\n        # return recipe_path, context\n        # e.g. if you edit them/change them\n</code></pre></p>"},{"location":"usage/#recipe","title":"Recipe","text":"<p>The Recipe is the main object that pulls this all together. It inherits from Folder, and adds the <code>pre_hooks</code> and <code>post_hooks</code> variables.</p> <p>When creating a recipe, you should add fields (the Folder object is based on pydantic) for context variables as required.</p> <p>There is a more specific CodeRecipe class which includes repo metadata, git configuration, and git initialisation and precommit install hooks, that is recommended for creating recipes that are code repositories.</p> <p>A good example recipe is nskit.recipes.python.api.APIRecipe, which includes inheritance from  nskit.recipes.python.package.PackageRecipe (inheriting from a python base recipe nskit.recipes.python.PyRecipe).</p> <p>For a more simple example for a general repo: <pre><code>from typing import List, Union\nfrom nskit.mixer import CodeRecipe, File, Folder\n\nclass MyRecipe(CodeRecipe):\n    contents: List[Union[File, Folder]] = [\n        Folder(name='my_recipe', contents=[\n            File(name='hello_world.txt', content='Hello world! from {{whoami}}')\n        ])\n    ]\n    # Adding a simple context variable\n    whoami: str\n    # This doesn't have a default so needs to be set when initialising the repo\n    # You could e.g. use pydantic validators or Field factories to initialise this dynamically as well\n</code></pre></p> <p>To make a recipe available to <code>nskit</code>, you need to make it an installable entrypoint, e.g. in <code>pyproject.toml</code>: <pre><code>[project.entry-points.\"nskit.recipes\"]\nmy_recipe = \"my_package.my_recipe:MyRecipe\"\n</code></pre></p> <p>and, when installed in the environment with nskit, will be available as <code>my_recipe</code> using the commands described in [Creating a repo from a recipe][]</p>"},{"location":"usage/#recipes-in-other-languages","title":"Recipes in other languages","text":"<p>It is possible to create additional installation handlers for other languages. This uses the <code>nskit.vcs.installers</code> entrypoint, and should inherit from nskit.vcs.installer.Installer.</p> <p>This has two abstract methods that should be implemented for a specific language:</p> <ul> <li><code>check_repo</code> - check if the repo is of the language/installer type</li> <li><code>install</code> - takes the repo path, current codebase (optional), and whether to install dependencies (<code>deps</code>) and gets the appropriate installation environment from the codebase or elsewhere.</li> </ul> <p>An example of this is the nskit.vcs.installer.PythonInstaller.</p> <p>This implements editable python package installation into a <code>virtualenv</code> in the codebase root. It has some specific configuration variables (that can be set using environment variables:</p> <ul> <li><code>NSKIT_PYTHON_INSTALLER_ENABLED</code> - set to false to disable</li> <li><code>NSKIT_PYTHON_INSTALLER_VIRTUALENV_DIR</code> - set a specific directory path, or directory name for the virtualenv dir to use</li> <li><code>NSKIT_PYTHON_INSTALLER_VIRTUALENV_ARGS</code> - specify any specific args for virtualenv.</li> </ul> <p>And provides the two methods mentioned above: * <code>check_repo</code> - checks if there is a <code>setup.py</code>, <code>pyproject.toml</code>, or <code>requirements.txt</code> file in the repo root * <code>install</code> - gets the virtualenv/other executable to use and installs with/without dependencies as configured.</p> <p>A similar installer can be implemented for other languages (using e.g. <code>subprocess</code> for running the installation).</p> <p>Note</p> <p>To set the environment variable names, use the <code>model_config</code> variable: <pre><code>    model_config = SettingsConfigDic(env_prefix='&lt;MY_ENV_PREFIX_&gt;', env_file='.env')\n</code></pre></p> <p>Warning</p> <p>All installers will be tried, and if they are enabled (using environment variables), and the repo passes the <code>check_repo</code> call, the install method will be called. This could cause issues for multi-language repos. For complex cases like that, we suggest using a custom installer and disabling the others.</p>"},{"location":"usage/#using-namespaces","title":"Using namespaces","text":"<p>Another key feature of <code>nskit</code> is handling namespaces. A namespace is e.g. a organisational or personal naming convention that makes it easy to identify and structure repositories and modules.</p> <p>For python code, this might look like <code>my_org.my_team.my_module</code>, but can look different for other languages. You may want to replicate this in my repository naming convention (which doesn't usually allow folders in repository names), and this can be done with the nskit.vcs.NamespaceValidationRepo, which can be created and stored in your VCS.</p> <p>The structure of the namespace file is a <code>namespace.yaml</code> file with valid names at a given level, e.g.: <pre><code>options;\n- my_org:\n    - my_team\n    - team_a:\n        - module_1\n        - module_2\n</code></pre> Which means we can have repos structured as: <pre><code>my_org-my_team-&lt;*&gt;\nmy_org-team_a-module_1\nmy_org-team_a-module_1-&lt;*&gt;\nmy_org-team_a-module_2\nmy_org-team_a-module_2-&lt;*&gt;\n</code></pre> But no others.</p> <p>You can create a namespace repo for a codebase:</p> <pre><code>from nskit.vcs import Codebase\n\nc = Codebase()\noptions = [{'my_org': ['my_team', {'team_a': ['module_1', 'module_2']}]}]\nc.create_namespace_repo(namespace_options=options)\n</code></pre> <p>There are additional parameters that you can set:</p> <ul> <li><code>repo_separator</code> defines the separator to use on the VCS repo names (defaults to <code>-</code>)</li> <li><code>delimiters</code> is a list of valid delimiters to use to split the names up (defaults to a standard set of <code>,</code>, <code>.</code>, <code>-</code>)</li> </ul> <p>You will also need to set the validation level to ensure name validation occurs when creating new repos.</p> <p><pre><code>c.settings.validation_level =  c.settings.validation_level.strict\n# Options are none (default), warning, and strict\n</code></pre> With strict validation and a <code>namespace_validation_repo</code> for the codebase, creating a repo with a non-matching name will error (otherwise it will just warn, or do nothing) <pre><code>c.create_repo(name='abc-def')\n# Raise a ValueError\n</code></pre></p> <p>If you are not using the full codebase behaviours, you can also set the <code>namespace_validation_repo</code> parameter on the nskit.vcs.repo.Repo object to enforce name validation.</p>"},{"location":"usage/#inheriting","title":"Inheriting","text":"<p><code>nskit</code> is designed to be used as a based for creating your own scaffolding for managing an organisational or personal codebase with namespaces.</p> <p>You can provide simple stubs in your own module/package for a few key classes:</p> <ul> <li>nskit.vcs.Codebase</li> <li>nskit.mixer.CodeRecipe</li> <li>nskit.mixer.Recipe</li> <li>nskit.mixer.File</li> <li>nskit.mixer.Folder</li> </ul> <p>which make it easy for people to refer to that (and add customisation, and e.g. additional extensions or recipes as required) for your internal use.</p>"},{"location":"usage/#extending-nskit","title":"Extending nskit","text":"<p><code>nskit</code> is designed around a few key entrypoints to make it easily accessible, including</p> <ul> <li><code>[project.entry-points.\"nskit.recipes\"]</code> for code recipes</li> <li><code>[project.entry-points.\"nskit.vcs.providers\"]</code> for other VCS providers</li> <li><code>[project.entry-points.\"nskit.mixer.environment.extensions\"]</code> for the mixer <code>jinja2</code> Environment extensions</li> <li><code>[project.entry-points.\"nskit.mixer.environment.factory\"]</code> for the mixer <code>jinja2</code> Environment initialisation</li> </ul> <p>Additionally, key methods and behaviours can be overwritten or extended using inheritance.</p>"},{"location":"usage/#customising-the-nskitmixer-jinja2-environment","title":"Customising the <code>nskit.mixer</code> <code>jinja2</code> <code>Environment</code>","text":"<p>There are 2 entrypoints to enable customising the Jinja Environment used for the template rendering.</p> <ul> <li><code>[project.entry-points.\"nskit.mixer.environment.extensions\"]</code> for the mixer <code>jinja2</code> Environment extensions</li> <li><code>[project.entry-points.\"nskit.mixer.environment.factory\"]</code> for the mixer <code>jinja2</code> Environment initialisation</li> </ul> <p>The first allows extension recipes to define a list of extensions to add to the environment (must be installed as dependencies of the recipe)</p> <p>An example might be: <pre><code>def recipe_jinja_extensions():\n    return ['jinja2.ext.debug', 'jinja2.ext.i8n']\n</code></pre></p> <p>This could be implemented as a staticmethod on the recipe object or similar, but it needs to be defined to the <code>nskit.mixer.environment.extensions</code> entrypoint in the <code>pyproject.toml</code>.</p> <p>Warning</p> <p>All requested extensions for installed recipes are added to the environment so it could be possible for clashes/issues to occur there, however given the maturity of the jinja ecosystem, we are not loading them recipe by recipe due to the added complexity/issues.</p> <p>You can also customise the environment initialisation if you need to override specifics of the configuration however this is not recommended as it can cause complex issues with the templates/handling.</p> <p>The default implementation defines the loader to use <code>_PkgResourcesTemplateLoader</code> to allow for package resources type loading on the environment (see examples above), but other parameters could be configured/changed by setting the <code>NSKIT_MIXER_JINJA_ENVIRONMENT_FACTORY</code> environment variable to the name of the entrypoint.</p> <p>Warning</p> <p>The default configurations are the expected one, so changing this could break e.g. inherited ingredients, so proceed with caution.</p>"},{"location":"api/nskit.common/","title":"nskit.common","text":"<p>Common utilities for nskit.</p>"},{"location":"api/nskit.common/#nskitcommonconfiguration","title":"nskit.common.configuration","text":"<p>Base configuration class.</p> Includes <ul> <li>properties in model dumps</li> <li>file based config loading (json/toml/yaml)</li> <li>model dumping to toml &amp; yaml</li> </ul>"},{"location":"api/nskit.common/#nskit.common.configuration.BaseConfiguration","title":"<code>BaseConfiguration</code>","text":"<p>             Bases: <code>PropertyDumpMixin</code>, <code>BaseSettings</code></p> <p>A Pydantic BaseSettings type object with Properties included in model dump, and yaml and toml integrations.</p> Source code in <code>nskit/common/configuration/__init__.py</code> <pre><code>class BaseConfiguration(PropertyDumpMixin, _BaseSettings):\n    \"\"\"A Pydantic BaseSettings type object with Properties included in model dump, and yaml and toml integrations.\"\"\"\n\n    model_config = _SettingsConfigDict(env_file_encoding='utf-8')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[_BaseSettings],\n        init_settings: _PydanticBaseSettingsSource,\n        env_settings: _PydanticBaseSettingsSource,\n        dotenv_settings: _PydanticBaseSettingsSource,\n        file_secret_settings: _PydanticBaseSettingsSource,\n    ) -&gt; tuple[_PydanticBaseSettingsSource, ...]:\n        \"\"\"Create settings loading, including the FileConfigSettingsSource.\"\"\"\n        # TODO This probably needs a tweak to handle complex structures.\n        return (\n            FileConfigSettingsSource(settings_cls),\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n        )\n\n    def model_dump_toml(\n            self,\n            *,\n            indent: int | None = None,\n            include: Any = None,\n            exclude: Any = None,\n            by_alias: bool = False,\n            exclude_unset: bool = False,\n            exclude_defaults: bool = False,\n            exclude_none: bool = False,\n            round_trip: bool = False,\n            warnings: bool = True):\n        \"\"\"Dump model to TOML.\"\"\"\n        # We go via JSON to include indent etc.\n        return toml.dumps(json.loads(self.model_dump_json(\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings\n        )))\n\n    def model_dump_yaml(\n            self,\n            *,\n            indent: int | None = None,\n            include: Any = None,\n            exclude: Any = None,\n            by_alias: bool = False,\n            exclude_unset: bool = False,\n            exclude_defaults: bool = False,\n            exclude_none: bool = False,\n            round_trip: bool = False,\n            warnings: bool = True):\n        \"\"\"Dump model to YAML.\"\"\"\n        # We go via JSON to include indent etc.\n        return yaml.dumps(json.loads(self.model_dump_json(\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings\n        )))\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.configuration.BaseConfiguration.model_dump_toml","title":"<code>model_dump_toml(*, indent=None, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True)</code>","text":"<p>Dump model to TOML.</p> Source code in <code>nskit/common/configuration/__init__.py</code> <pre><code>def model_dump_toml(\n        self,\n        *,\n        indent: int | None = None,\n        include: Any = None,\n        exclude: Any = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool = True):\n    \"\"\"Dump model to TOML.\"\"\"\n    # We go via JSON to include indent etc.\n    return toml.dumps(json.loads(self.model_dump_json(\n        indent=indent,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        warnings=warnings\n    )))\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.configuration.BaseConfiguration.model_dump_yaml","title":"<code>model_dump_yaml(*, indent=None, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True)</code>","text":"<p>Dump model to YAML.</p> Source code in <code>nskit/common/configuration/__init__.py</code> <pre><code>def model_dump_yaml(\n        self,\n        *,\n        indent: int | None = None,\n        include: Any = None,\n        exclude: Any = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool = True):\n    \"\"\"Dump model to YAML.\"\"\"\n    # We go via JSON to include indent etc.\n    return yaml.dumps(json.loads(self.model_dump_json(\n        indent=indent,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        warnings=warnings\n    )))\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.configuration.BaseConfiguration.settings_customise_sources","title":"<code>settings_customise_sources(settings_cls, init_settings, env_settings, dotenv_settings, file_secret_settings)</code>  <code>classmethod</code>","text":"<p>Create settings loading, including the FileConfigSettingsSource.</p> Source code in <code>nskit/common/configuration/__init__.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[_BaseSettings],\n    init_settings: _PydanticBaseSettingsSource,\n    env_settings: _PydanticBaseSettingsSource,\n    dotenv_settings: _PydanticBaseSettingsSource,\n    file_secret_settings: _PydanticBaseSettingsSource,\n) -&gt; tuple[_PydanticBaseSettingsSource, ...]:\n    \"\"\"Create settings loading, including the FileConfigSettingsSource.\"\"\"\n    # TODO This probably needs a tweak to handle complex structures.\n    return (\n        FileConfigSettingsSource(settings_cls),\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/nskit.common/#nskitcommoncontextmanagers","title":"nskit.common.contextmanagers","text":"<p>Reusable context managers.</p>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.ChDir","title":"<code>ChDir</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>Context manager for running in a specified (or temporary) directory.</p> <p>The optional argument is a path to a specified target directory, if this isn't provided, a temporary directory is created</p> Source code in <code>nskit/common/contextmanagers/chdir.py</code> <pre><code>class ChDir(ContextDecorator):\n    \"\"\"Context manager for running in a specified (or temporary) directory.\n\n    The optional argument is a path to a specified target directory, if this isn't provided, a temporary directory is created\n    \"\"\"\n\n    def __init__(self, target_dir: Optional[Path] = None):\n        \"\"\"Initialise the context manager.\n\n        Keyword Args:\n            target_dir (Optional[Path]): the target directory\n        \"\"\"\n        self._temp_dir = None\n        if not target_dir:\n            # Handling circular imports with LoggingConfig\n            logger_factory.get_logger(__name__).debug('No target_dir provided, using a temporary directory')\n            self._temp_dir = tempfile.TemporaryDirectory()\n            target_dir = self._temp_dir.name\n        self.cwd = Path.cwd()\n        self.target_dir = Path(target_dir)\n\n    def __enter__(self):\n        \"\"\"Change to the target directory.\"\"\"\n        # Handling circular imports with LoggingConfig\n        logger_factory.get_logger(__name__).info(f'Changing to {self.target_dir}')\n        if not self.target_dir.exists():\n            self.target_dir.mkdir()\n        os.chdir(str(self.target_dir))\n        if self._temp_dir:\n            return self._temp_dir.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Reset to the original directory.\"\"\"\n        os.chdir(str(self.cwd))\n        if self._temp_dir:\n            try:\n                self.target_dir.__exit__(exc_type, exc_val, exc_tb)\n            except PermissionError as e:\n                # Handling circular imports with LoggingConfig\n                logger_factory.get_logger(__name__).warn('Unable to delete temporary directory.')\n                warnings.warn(e, stacklevel=2)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.ChDir.__enter__","title":"<code>__enter__()</code>","text":"<p>Change to the target directory.</p> Source code in <code>nskit/common/contextmanagers/chdir.py</code> <pre><code>def __enter__(self):\n    \"\"\"Change to the target directory.\"\"\"\n    # Handling circular imports with LoggingConfig\n    logger_factory.get_logger(__name__).info(f'Changing to {self.target_dir}')\n    if not self.target_dir.exists():\n        self.target_dir.mkdir()\n    os.chdir(str(self.target_dir))\n    if self._temp_dir:\n        return self._temp_dir.__enter__()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.ChDir.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Reset to the original directory.</p> Source code in <code>nskit/common/contextmanagers/chdir.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Reset to the original directory.\"\"\"\n    os.chdir(str(self.cwd))\n    if self._temp_dir:\n        try:\n            self.target_dir.__exit__(exc_type, exc_val, exc_tb)\n        except PermissionError as e:\n            # Handling circular imports with LoggingConfig\n            logger_factory.get_logger(__name__).warn('Unable to delete temporary directory.')\n            warnings.warn(e, stacklevel=2)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.ChDir.__init__","title":"<code>__init__(target_dir=None)</code>","text":"<p>Initialise the context manager.</p> <p>Other Parameters:</p> Name Type Description <code>target_dir</code> <code>Optional[Path]</code> <p>the target directory</p> Source code in <code>nskit/common/contextmanagers/chdir.py</code> <pre><code>def __init__(self, target_dir: Optional[Path] = None):\n    \"\"\"Initialise the context manager.\n\n    Keyword Args:\n        target_dir (Optional[Path]): the target directory\n    \"\"\"\n    self._temp_dir = None\n    if not target_dir:\n        # Handling circular imports with LoggingConfig\n        logger_factory.get_logger(__name__).debug('No target_dir provided, using a temporary directory')\n        self._temp_dir = tempfile.TemporaryDirectory()\n        target_dir = self._temp_dir.name\n    self.cwd = Path.cwd()\n    self.target_dir = Path(target_dir)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.Env","title":"<code>Env</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>Context manager for managing environment variables.</p> <p>The optional arguments can provide either an exhaustive set of environment values, values to override or values to remove.</p> Source code in <code>nskit/common/contextmanagers/env.py</code> <pre><code>class Env(ContextDecorator):\n    \"\"\"Context manager for managing environment variables.\n\n    The optional arguments can provide either an exhaustive set of environment values, values to override or values to remove.\n    \"\"\"\n\n    def __init__(\n            self,\n            environ: Optional[Dict[str, str]] = None,\n            override: Optional[Dict[str, str]] = None,\n            remove: Optional[List[str]] = None\n            ):\n        \"\"\"Initialise the context manager.\n\n        The parameters are applied in the following order (so can be combined): 1st - environ, 2nd - override, 3rd - remove\n\n        Keyword Args:\n            environ (Optional[Dict[str, str]]): an exhaustive set of environment values to set (replaces overall os.environ contents)\n            override (Optional[Dict[str, str]]): a set of environment values to either override or set (replaces values in existing os.environ)\n            remove (Optional[List[str]]): a set of environment values to remove (removes values if found in os.environ )\n        \"\"\"\n        if environ is not None and not isinstance(environ, dict):\n            raise TypeError('environ should be a dict')\n        if override is not None and not isinstance(override, dict):\n            raise TypeError('override should be a dict')\n        if remove is not None and not isinstance(remove, (list, tuple, set)):\n            raise TypeError('remove should be a (list, tuple, set)')\n        self._environ = environ\n        self._override = override\n        self._remove = remove\n        self._original = None\n\n    def __enter__(self):\n        \"\"\"Change to the target environment variables.\"\"\"\n        # Handling circular imports with LoggingConfig\n        logger = logger_factory.get_logger(__name__)\n        if self._environ or self._override or self._remove:\n            self._original = os.environ.copy()\n            if self._environ is not None:\n                # Here we pop all keys from it and then update\n                os.environ.clear()\n                os.environ.update(self._environ)\n            if self._override:\n                os.environ.update(self._override)\n            if self._remove:\n                for key in list(self._remove):\n                    os.environ.pop(key, None)\n            logger.info('Changing env variables')\n            logger.debug(f'New env variables: {os.environ}')\n        else:\n            logger.info('No arguments set (environ, override, remove)')\n\n    def __exit__(self, *args, **kwargs):  # noqa: U100\n        \"\"\"Reset to the original environment variables.\"\"\"\n        if self._original:\n            os.environ.clear()\n            os.environ.update(self._original.copy())\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.Env.__enter__","title":"<code>__enter__()</code>","text":"<p>Change to the target environment variables.</p> Source code in <code>nskit/common/contextmanagers/env.py</code> <pre><code>def __enter__(self):\n    \"\"\"Change to the target environment variables.\"\"\"\n    # Handling circular imports with LoggingConfig\n    logger = logger_factory.get_logger(__name__)\n    if self._environ or self._override or self._remove:\n        self._original = os.environ.copy()\n        if self._environ is not None:\n            # Here we pop all keys from it and then update\n            os.environ.clear()\n            os.environ.update(self._environ)\n        if self._override:\n            os.environ.update(self._override)\n        if self._remove:\n            for key in list(self._remove):\n                os.environ.pop(key, None)\n        logger.info('Changing env variables')\n        logger.debug(f'New env variables: {os.environ}')\n    else:\n        logger.info('No arguments set (environ, override, remove)')\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.Env.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Reset to the original environment variables.</p> Source code in <code>nskit/common/contextmanagers/env.py</code> <pre><code>def __exit__(self, *args, **kwargs):  # noqa: U100\n    \"\"\"Reset to the original environment variables.\"\"\"\n    if self._original:\n        os.environ.clear()\n        os.environ.update(self._original.copy())\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.Env.__init__","title":"<code>__init__(environ=None, override=None, remove=None)</code>","text":"<p>Initialise the context manager.</p> <p>The parameters are applied in the following order (so can be combined): 1st - environ, 2nd - override, 3rd - remove</p> <p>Other Parameters:</p> Name Type Description <code>environ</code> <code>Optional[Dict[str, str]]</code> <p>an exhaustive set of environment values to set (replaces overall os.environ contents)</p> <code>override</code> <code>Optional[Dict[str, str]]</code> <p>a set of environment values to either override or set (replaces values in existing os.environ)</p> <code>remove</code> <code>Optional[List[str]]</code> <p>a set of environment values to remove (removes values if found in os.environ )</p> Source code in <code>nskit/common/contextmanagers/env.py</code> <pre><code>def __init__(\n        self,\n        environ: Optional[Dict[str, str]] = None,\n        override: Optional[Dict[str, str]] = None,\n        remove: Optional[List[str]] = None\n        ):\n    \"\"\"Initialise the context manager.\n\n    The parameters are applied in the following order (so can be combined): 1st - environ, 2nd - override, 3rd - remove\n\n    Keyword Args:\n        environ (Optional[Dict[str, str]]): an exhaustive set of environment values to set (replaces overall os.environ contents)\n        override (Optional[Dict[str, str]]): a set of environment values to either override or set (replaces values in existing os.environ)\n        remove (Optional[List[str]]): a set of environment values to remove (removes values if found in os.environ )\n    \"\"\"\n    if environ is not None and not isinstance(environ, dict):\n        raise TypeError('environ should be a dict')\n    if override is not None and not isinstance(override, dict):\n        raise TypeError('override should be a dict')\n    if remove is not None and not isinstance(remove, (list, tuple, set)):\n        raise TypeError('remove should be a (list, tuple, set)')\n    self._environ = environ\n    self._override = override\n    self._remove = remove\n    self._original = None\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.TestExtension","title":"<code>TestExtension</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>Context manager for running a test of an entrypoint.</p> Source code in <code>nskit/common/contextmanagers/test_extensions.py</code> <pre><code>class TestExtension(ContextDecorator):\n    \"\"\"Context manager for running a test of an entrypoint.\"\"\"\n\n    def __init__(self, name: str, group: str, entrypoint: type, *, solo: bool = False):\n        \"\"\"Initialise the context manager.\n\n        Keyword Args:\n            name (str): the extension name\n            group (str): the extension group\n            entrypoint (type): the object/type to load in the entrypoint\n            solo (bool): set so only that entrypoint will be found (can cause side-effects)\n        \"\"\"\n        self.ep = _TestEntrypoint(name=name, group=group, entrypoint=entrypoint, solo=solo)\n        self._clean = False\n\n    def __enter__(self):\n        \"\"\"Add the extension so it can be loaded.\"\"\"\n        logger_factory.get_logger(__name__).info(f'Starting entrypoint for extension {self.ep.name} in {self.ep.group}')\n        self.ep.start()\n\n    def __exit__(self, *args, **kwargs):  # noqa: U100\n        \"\"\"Remove the extension and return to the original.\"\"\"\n        logger_factory.get_logger(__name__).info(f'Stoppings entrypoint for extension {self.ep.name} in {self.ep.group}')\n        self.ep.stop()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.TestExtension.__enter__","title":"<code>__enter__()</code>","text":"<p>Add the extension so it can be loaded.</p> Source code in <code>nskit/common/contextmanagers/test_extensions.py</code> <pre><code>def __enter__(self):\n    \"\"\"Add the extension so it can be loaded.\"\"\"\n    logger_factory.get_logger(__name__).info(f'Starting entrypoint for extension {self.ep.name} in {self.ep.group}')\n    self.ep.start()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.TestExtension.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Remove the extension and return to the original.</p> Source code in <code>nskit/common/contextmanagers/test_extensions.py</code> <pre><code>def __exit__(self, *args, **kwargs):  # noqa: U100\n    \"\"\"Remove the extension and return to the original.\"\"\"\n    logger_factory.get_logger(__name__).info(f'Stoppings entrypoint for extension {self.ep.name} in {self.ep.group}')\n    self.ep.stop()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.contextmanagers.TestExtension.__init__","title":"<code>__init__(name, group, entrypoint, *, solo=False)</code>","text":"<p>Initialise the context manager.</p> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>the extension name</p> <code>group</code> <code>str</code> <p>the extension group</p> <code>entrypoint</code> <code>type</code> <p>the object/type to load in the entrypoint</p> <code>solo</code> <code>bool</code> <p>set so only that entrypoint will be found (can cause side-effects)</p> Source code in <code>nskit/common/contextmanagers/test_extensions.py</code> <pre><code>def __init__(self, name: str, group: str, entrypoint: type, *, solo: bool = False):\n    \"\"\"Initialise the context manager.\n\n    Keyword Args:\n        name (str): the extension name\n        group (str): the extension group\n        entrypoint (type): the object/type to load in the entrypoint\n        solo (bool): set so only that entrypoint will be found (can cause side-effects)\n    \"\"\"\n    self.ep = _TestEntrypoint(name=name, group=group, entrypoint=entrypoint, solo=solo)\n    self._clean = False\n</code></pre>"},{"location":"api/nskit.common/#nskitcommonextensions","title":"nskit.common.extensions","text":"<p>Common extension helpers.</p>"},{"location":"api/nskit.common/#nskit.common.extensions.ExtensionsEnum","title":"<code>ExtensionsEnum</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum created from available extensions on an entrypoint.</p> Source code in <code>nskit/common/extensions.py</code> <pre><code>class ExtensionsEnum(Enum):\n    \"\"\"Enum created from available extensions on an entrypoint.\"\"\"\n\n    @classmethod\n    def from_entrypoint(cls, name: str, entrypoint: str):\n        \"\"\"Create the enum with name, from entrypoint options.\"\"\"\n        options = {u: u for u in get_extension_names(entrypoint)}\n        kls = cls(name, options)\n        kls.__entrypoint__ = entrypoint\n        return kls\n\n    @property\n    def extension(self):\n        \"\"\"Load the extension.\"\"\"\n        return load_extension(self.__entrypoint__, self.value)\n\n    @classmethod\n    def _patch(cls):\n        \"\"\"Used for testing and patching objects.\"\"\"\n        options = {u: u for u in get_extension_names(cls.__entrypoint__)}\n        # Loop over options not in members\n        for key in options:\n            if key not in cls._member_names_:\n                extend_enum(cls, key, key)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.extensions.ExtensionsEnum.extension","title":"<code>extension</code>  <code>property</code>","text":"<p>Load the extension.</p>"},{"location":"api/nskit.common/#nskit.common.extensions.ExtensionsEnum.from_entrypoint","title":"<code>from_entrypoint(name, entrypoint)</code>  <code>classmethod</code>","text":"<p>Create the enum with name, from entrypoint options.</p> Source code in <code>nskit/common/extensions.py</code> <pre><code>@classmethod\ndef from_entrypoint(cls, name: str, entrypoint: str):\n    \"\"\"Create the enum with name, from entrypoint options.\"\"\"\n    options = {u: u for u in get_extension_names(entrypoint)}\n    kls = cls(name, options)\n    kls.__entrypoint__ = entrypoint\n    return kls\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.extensions.get_extension_names","title":"<code>get_extension_names(entrypoint)</code>","text":"<p>Get all installed extension names for a given entrypoint.</p> Source code in <code>nskit/common/extensions.py</code> <pre><code>def get_extension_names(entrypoint: str):\n    \"\"\"Get all installed extension names for a given entrypoint.\"\"\"\n    extensions = []\n    for ep in entry_points().select(group=entrypoint):\n        extensions.append(ep.name)\n    logger_factory.get_logger(__name__).debug(f'Identified extensions {extensions} for entrypoint {entrypoint}')\n    return extensions\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.extensions.get_extensions","title":"<code>get_extensions(entrypoint)</code>","text":"<p>Load all extensions for a given entrypoint.</p> Source code in <code>nskit/common/extensions.py</code> <pre><code>def get_extensions(entrypoint: str):\n    \"\"\"Load all extensions for a given entrypoint.\"\"\"\n    extensions = {}\n    for ep in entry_points().select(group=entrypoint):\n        extensions[ep.name] = ep\n    logger_factory.get_logger(__name__).debug(f'Identified extensions {extensions} for entrypoint {entrypoint}')\n    return extensions\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.extensions.load_extension","title":"<code>load_extension(entrypoint, extension)</code>","text":"<p>Load a given extension for a given entrypoint.</p> Source code in <code>nskit/common/extensions.py</code> <pre><code>def load_extension(entrypoint: str, extension: str):\n    \"\"\"Load a given extension for a given entrypoint.\"\"\"\n    for ep in entry_points().select(group=entrypoint, name=extension):\n        return ep.load()\n    logger_factory.get_logger(__name__).warn(f'Entrypoint {extension} not found for {entrypoint}')\n</code></pre>"},{"location":"api/nskit.common/#nskitcommonio","title":"nskit.common.io","text":"<p>File IO handlers.</p>"},{"location":"api/nskit.common/#nskitcommoniojson","title":"nskit.common.io.json","text":"<p>Provide a JSON Load/Dump API consistent with stdlib JSON.</p>"},{"location":"api/nskit.common/#nskit.common.io.json.dump","title":"<code>dump(data, f, /, default=None, option=None, **kwargs)</code>","text":"<p>Dump JSON to file.</p> Source code in <code>nskit/common/io/json.py</code> <pre><code>def dump(data: Any, f: TextIO, /, default: Optional[Any] = None, option: Optional[int] = None, **kwargs):\n    \"\"\"Dump JSON to file.\"\"\"\n    f.write(dumps(data, default=default, option=option, **kwargs))\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.json.dumps","title":"<code>dumps(data, /, default=None, option=None, **kwargs)</code>","text":"<p>Dump JSON to string.</p> Source code in <code>nskit/common/io/json.py</code> <pre><code>def dumps(data: Any, /, default: Optional[Any] = None, option: Optional[int] = None, **kwargs):\n    \"\"\"Dump JSON to string.\"\"\"\n    return orjson.dumps(data, default=default, option=option, **kwargs).decode()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.json.load","title":"<code>load(fp, **kwargs)</code>","text":"<p>Load JSON from file.</p> Source code in <code>nskit/common/io/json.py</code> <pre><code>def load(fp: TextIO, **kwargs):\n    \"\"\"Load JSON from file.\"\"\"\n    return loads(fp.read(), **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.json.loads","title":"<code>loads(s, **kwargs)</code>","text":"<p>Load JSON from string.</p> Source code in <code>nskit/common/io/json.py</code> <pre><code>def loads(s: str, **kwargs):\n    \"\"\"Load JSON from string.\"\"\"\n    return orjson.loads(s, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskitcommoniotoml","title":"nskit.common.io.toml","text":"<p>Provide a TOML Load/Dump API consistent with JSON.</p>"},{"location":"api/nskit.common/#nskit.common.io.toml.dump","title":"<code>dump(data, fp, sort_keys=False, **kwargs)</code>","text":"<p>Load TOML to file/stream.</p> Source code in <code>nskit/common/io/toml.py</code> <pre><code>def dump(data: Mapping, fp: TextIO, sort_keys: bool = False, **kwargs):\n    \"\"\"Load TOML to file/stream.\"\"\"\n    return tomlkit.dump(data, fp, sort_keys=sort_keys, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.toml.dumps","title":"<code>dumps(data, sort_keys=False, **kwargs)</code>","text":"<p>Dump TOML to string.</p> Source code in <code>nskit/common/io/toml.py</code> <pre><code>def dumps(data: Mapping, sort_keys: bool = False, **kwargs):\n    \"\"\"Dump TOML to string.\"\"\"\n    return tomlkit.dumps(data, sort_keys=sort_keys, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.toml.load","title":"<code>load(fp, **kwargs)</code>","text":"<p>Load TOML from file/stream.</p> Source code in <code>nskit/common/io/toml.py</code> <pre><code>def load(fp: TextIO, **kwargs):\n    \"\"\"Load TOML from file/stream.\"\"\"\n    return tomlkit.load(fp, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.toml.loads","title":"<code>loads(s, **kwargs)</code>","text":"<p>Load TOML from string.</p> Source code in <code>nskit/common/io/toml.py</code> <pre><code>def loads(s: str, **kwargs):\n    \"\"\"Load TOML from string.\"\"\"\n    return tomlkit.loads(s, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskitcommonioyaml","title":"nskit.common.io.yaml","text":"<p>Provide a YAML 1.2 Load/Dump API consistent with JSON.</p>"},{"location":"api/nskit.common/#nskit.common.io.yaml.dump","title":"<code>dump(data, stream, *, typ='rt', **kwargs)</code>","text":"<p>Dump YAML to file/stream.</p> Source code in <code>nskit/common/io/yaml.py</code> <pre><code>def dump(data: Any, stream: TextIO, *, typ: str = 'rt', **kwargs):\n    \"\"\"Dump YAML to file/stream.\"\"\"\n    return _YAML(typ=typ).dump(data, stream=stream, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.yaml.dumps","title":"<code>dumps(data, *, typ='rt', **kwargs)</code>","text":"<p>Dump YAML to string.</p> Source code in <code>nskit/common/io/yaml.py</code> <pre><code>def dumps(data: Any, *, typ: str = 'rt', **kwargs):\n    \"\"\"Dump YAML to string.\"\"\"\n    s = StringIO()\n    dump(data, s, typ=typ, **kwargs)\n    return s.getvalue()\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.yaml.load","title":"<code>load(stream, *, typ='rt', **kwargs)</code>","text":"<p>Load YAML from file/stream.</p> Source code in <code>nskit/common/io/yaml.py</code> <pre><code>def load(stream: TextIO, *, typ: str = 'rt', **kwargs):\n    \"\"\"Load YAML from file/stream.\"\"\"\n    return _YAML(typ=typ).load(stream, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.io.yaml.loads","title":"<code>loads(s, *, typ='rt', **kwargs)</code>","text":"<p>Load YAML from string.</p> Source code in <code>nskit/common/io/yaml.py</code> <pre><code>def loads(s: str, *, typ: str = 'rt', **kwargs):\n    \"\"\"Load YAML from string.\"\"\"\n    return load(StringIO(s), typ=typ, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskitcommonlogging","title":"nskit.common.logging","text":"<p>Common logging helpers.</p>"},{"location":"api/nskit.common/#nskit.common.logging.LoggingConfig","title":"<code>LoggingConfig</code>","text":"<p>             Bases: <code>BaseConfiguration</code></p> <p>This is a basic config for logging.</p> Source code in <code>nskit/common/logging/config.py</code> <pre><code>class LoggingConfig(BaseConfiguration):\n    \"\"\"This is a basic config for logging.\"\"\"\n\n    # TODO setup as settings\n    level: str = Field(DEFAULT_LOGLEVEL, description='Set the log level for the logger')\n    logfile: Optional[Path] = Field(None, validation_alias=AliasChoices('logfile', LOGFILE_ENV_VAR), description='Set the log file for the logger')\n    format_string: str = Field(BASE_FORMAT_STR, validation_alias=AliasChoices('format_string', LOGFORMATSTRING_ENV_VAR), description='Set the log format for the logger')\n    json_format: bool = Field(True, validation_alias=AliasChoices('json_format', JSON_ENV_VAR), serialization_alias='json', description='Output JSON Logs', alias='json')\n    extra: Dict[str, Any] = Field(default_factory=dict, description=\"Extra kwargs\")\n\n    @property\n    def formatter(self):\n        \"\"\"Return the logging formatter for the format string.\"\"\"\n        return LoggingFormatter(self.format_string)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.LoggingConfig.formatter","title":"<code>formatter</code>  <code>property</code>","text":"<p>Return the logging formatter for the format string.</p>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory","title":"<code>LibraryLoggerFactory</code>","text":"<p>A factory for creating multiple library loggers.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>class LibraryLoggerFactory:\n    \"\"\"A factory for creating multiple library loggers.\"\"\"\n\n    def __init__(self, library: str, version: str, base_config: Optional[Union[LoggingConfig, Dict[str, Any]]] = None):\n        \"\"\"Initialise the logger factory.\"\"\"\n        self.__library = library\n        self.__version = version\n        self.__base_config = base_config\n\n    def get_logger(self, name, config=None, **kwargs):\n        \"\"\"Get the library logger.\"\"\"\n        if config is None:\n            config = self.__base_config\n        return get_library_logger(self.library, self.version, name, config, **kwargs)\n\n    def get(self, name, config=None, **kwargs):\n        \"\"\"Alias for the get_logger method.\"\"\"\n        return self.get_logger(name, config, **kwargs)\n\n    def getLogger(self, name, config=None, **kwargs):\n        \"\"\"Alias for the get_logger method to provide parity with the standard logging API.\"\"\"\n        return self.get_logger(name, config, **kwargs)\n\n    @property\n    def library(self):\n        \"\"\"Return the library name.\"\"\"\n        return self.__library\n\n    @property\n    def version(self):\n        \"\"\"Return the version name.\"\"\"\n        return self.__version\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.library","title":"<code>library</code>  <code>property</code>","text":"<p>Return the library name.</p>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.version","title":"<code>version</code>  <code>property</code>","text":"<p>Return the version name.</p>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.__init__","title":"<code>__init__(library, version, base_config=None)</code>","text":"<p>Initialise the logger factory.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>def __init__(self, library: str, version: str, base_config: Optional[Union[LoggingConfig, Dict[str, Any]]] = None):\n    \"\"\"Initialise the logger factory.\"\"\"\n    self.__library = library\n    self.__version = version\n    self.__base_config = base_config\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.get","title":"<code>get(name, config=None, **kwargs)</code>","text":"<p>Alias for the get_logger method.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>def get(self, name, config=None, **kwargs):\n    \"\"\"Alias for the get_logger method.\"\"\"\n    return self.get_logger(name, config, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.getLogger","title":"<code>getLogger(name, config=None, **kwargs)</code>","text":"<p>Alias for the get_logger method to provide parity with the standard logging API.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>def getLogger(self, name, config=None, **kwargs):\n    \"\"\"Alias for the get_logger method to provide parity with the standard logging API.\"\"\"\n    return self.get_logger(name, config, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.LibraryLoggerFactory.get_logger","title":"<code>get_logger(name, config=None, **kwargs)</code>","text":"<p>Get the library logger.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>def get_logger(self, name, config=None, **kwargs):\n    \"\"\"Get the library logger.\"\"\"\n    if config is None:\n        config = self.__base_config\n    return get_library_logger(self.library, self.version, name, config, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.getLogger","title":"<code>getLogger(name, config=None, **kwargs)</code>","text":"<p>Get the logger object.</p> <p>wraps get_logger.</p> Source code in <code>nskit/common/logging/__init__.py</code> <pre><code>@wraps(get_logger)\ndef getLogger(name, config=None, **kwargs):\n    \"\"\"Get the logger object.\n\n    wraps get_logger.\n    \"\"\"\n    return get_logger(name, config, **kwargs)\n</code></pre>"},{"location":"api/nskit.common/#nskit.common.logging.get_library_logger","title":"<code>get_library_logger(library, version, name, config=None, **kwargs)</code>","text":"<p>Get a (sub)logger for a library component, which includes the library and version.</p> Source code in <code>nskit/common/logging/library.py</code> <pre><code>def get_library_logger(library: str, version: str, name: str, config: Optional[Union[LoggingConfig, Dict[str, Any]]] = None, **kwargs):\n    \"\"\"Get a (sub)logger for a library component, which includes the library and version.\"\"\"\n    if config is None:\n        config = {'extra': {}}\n    elif isinstance(config, LoggingConfig):\n        config = config.model_dump()\n    formatstr = get_library_log_format_string(library, version)\n    library = {'name': library, 'version': version}\n    config['format_string'] = formatstr\n    config['extra'] = config.get('extra', {})\n    config['extra'].update(kwargs.pop('extra', {}))\n    config = LoggingConfig(**config)\n    if config.json_format:\n        config.extra['library'] = library\n    return get_logger(name, config, **kwargs)\n</code></pre>"},{"location":"api/nskit.mixer/","title":"nskit.mixer","text":"<p>nskit.mixer.</p> <p>Building blocks to build up repo templates and mix (instantiate) them.</p>"},{"location":"api/nskit.mixer/#nskitmixercomponents","title":"nskit.mixer.components","text":"<p>nskit.mixer components for building recipes.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.components.File","title":"<code>File</code>","text":"<p>             Bases: <code>FileSystemObject</code></p> <p>File component.</p> Source code in <code>nskit/mixer/components/file.py</code> <pre><code>class File(FileSystemObject):\n    \"\"\"File component.\"\"\"\n\n    content: Union[Resource, str, bytes, Path, Callable] = Field('', description='The file content')\n\n    def render_content(self, context: Dict[str, Any]):  # pylint: disable=arguments-differ\n        \"\"\"Return the rendered content using the context and the Jinja environment.\"\"\"\n        if context is None:\n            context = {}\n        if isinstance(self.content, Resource):\n            content = self.content.load()\n        elif isinstance(self.content, Path):\n            with open(self.content) as f:\n                content = f.read()\n        elif isinstance(self.content, Callable):\n            content = self.content(context)\n        else:\n            content = self.content\n        if isinstance(content, str):\n            # If it is a string, we render the content\n            content = JINJA_ENVIRONMENT_FACTORY.environment.from_string(content).render(**context)\n        return content\n\n    def write(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Write the rendered content to the appropriate path within the ``base_path``.\"\"\"\n        file_path = self.get_path(base_path, context, override_path)\n        content = self.render_content(context)\n        response = {}\n        if content is not None:\n            if isinstance(content, str):\n                open_str = 'w'\n            elif isinstance(content, bytes):\n                open_str = 'wb'\n            with file_path.open(open_str) as output_file:\n                output_file.write(content)\n            response[file_path] = content\n        return response\n\n    def dryrun(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Preview the file contents using the context.\"\"\"\n        file_path = self.get_path(base_path, context, override_path)\n        content = self.render_content(context)\n        result = {}\n        if content is not None:\n            result[file_path] = content\n        return result\n\n    def validate(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Validate the output against expected.\"\"\"\n        missing = []\n        errors = []\n        ok = []\n        path = self.get_path(base_path, context, override_path)\n        content = self.render_content(context)\n        if content is not None:\n            if not path.exists():\n                missing.append(path)\n            else:\n                if isinstance(content, bytes):\n                    read_str = 'rb'\n                else:\n                    read_str = 'r'\n                with open(path, read_str) as f:\n                    if f.read() != self.render_content(context):\n                        errors.append(path)\n                    else:\n                        ok.append(path)\n        return missing, errors, ok\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.File.dryrun","title":"<code>dryrun(base_path, context, override_path=None)</code>","text":"<p>Preview the file contents using the context.</p> Source code in <code>nskit/mixer/components/file.py</code> <pre><code>def dryrun(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Preview the file contents using the context.\"\"\"\n    file_path = self.get_path(base_path, context, override_path)\n    content = self.render_content(context)\n    result = {}\n    if content is not None:\n        result[file_path] = content\n    return result\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.File.render_content","title":"<code>render_content(context)</code>","text":"<p>Return the rendered content using the context and the Jinja environment.</p> Source code in <code>nskit/mixer/components/file.py</code> <pre><code>def render_content(self, context: Dict[str, Any]):  # pylint: disable=arguments-differ\n    \"\"\"Return the rendered content using the context and the Jinja environment.\"\"\"\n    if context is None:\n        context = {}\n    if isinstance(self.content, Resource):\n        content = self.content.load()\n    elif isinstance(self.content, Path):\n        with open(self.content) as f:\n            content = f.read()\n    elif isinstance(self.content, Callable):\n        content = self.content(context)\n    else:\n        content = self.content\n    if isinstance(content, str):\n        # If it is a string, we render the content\n        content = JINJA_ENVIRONMENT_FACTORY.environment.from_string(content).render(**context)\n    return content\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.File.validate","title":"<code>validate(base_path, context, override_path=None)</code>","text":"<p>Validate the output against expected.</p> Source code in <code>nskit/mixer/components/file.py</code> <pre><code>def validate(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Validate the output against expected.\"\"\"\n    missing = []\n    errors = []\n    ok = []\n    path = self.get_path(base_path, context, override_path)\n    content = self.render_content(context)\n    if content is not None:\n        if not path.exists():\n            missing.append(path)\n        else:\n            if isinstance(content, bytes):\n                read_str = 'rb'\n            else:\n                read_str = 'r'\n            with open(path, read_str) as f:\n                if f.read() != self.render_content(context):\n                    errors.append(path)\n                else:\n                    ok.append(path)\n    return missing, errors, ok\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.File.write","title":"<code>write(base_path, context, override_path=None)</code>","text":"<p>Write the rendered content to the appropriate path within the <code>base_path</code>.</p> Source code in <code>nskit/mixer/components/file.py</code> <pre><code>def write(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Write the rendered content to the appropriate path within the ``base_path``.\"\"\"\n    file_path = self.get_path(base_path, context, override_path)\n    content = self.render_content(context)\n    response = {}\n    if content is not None:\n        if isinstance(content, str):\n            open_str = 'w'\n        elif isinstance(content, bytes):\n            open_str = 'wb'\n        with file_path.open(open_str) as output_file:\n            output_file.write(content)\n        response[file_path] = content\n    return response\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder","title":"<code>Folder</code>","text":"<p>             Bases: <code>FileSystemObject</code></p> <p>Folder component.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>class Folder(FileSystemObject):\n    \"\"\"Folder component.\"\"\"\n\n    contents: List[Union[File, 'Folder']] = Field(default_factory=list, description='The folder contents')\n\n    def write(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Write the rendered content to the appropriate path within the ``base_path``.\"\"\"\n        folder_path = self.get_path(base_path, context, override_path)\n        folder_path.mkdir(exist_ok=True, parents=True)\n        contents_dict = {}\n        for obj in self.contents:\n            contents_dict.update(obj.write(folder_path, context))\n        return {folder_path: contents_dict}\n\n    def dryrun(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Preview the file contents using the context.\"\"\"\n        folder_path = self.get_path(base_path, context, override_path)\n        contents_dict = {}\n        for u in self.contents:\n            contents_dict.update(u.dryrun(folder_path, context))\n        result = {folder_path: contents_dict}\n        return result\n\n    def validate(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n        \"\"\"Validate the output against expected.\"\"\"\n        missing = []\n        errors = []\n        ok = []\n        path = self.get_path(base_path, context, override_path)\n        if not path.exists():\n            missing.append(path)\n        for child in self.contents:\n            child_missing, child_errors, child_ok = child.validate(path, context)\n            missing += child_missing\n            errors += child_errors\n            ok += child_ok\n        if not missing and not errors:\n            ok.append(path)\n        return missing, errors, ok\n\n    @field_validator('contents', mode='before')\n    @classmethod\n    def _validate_contents_ids_unique(cls, contents):\n        if contents:\n            ids_ = []\n            for item in contents:\n                id_ = None\n                if isinstance(item, FileSystemObject):\n                    id_ = item.id_\n                if isinstance(item, dict):\n                    id_ = item.get('id_', None)\n                if id_ is None:\n                    # No id_ provided\n                    continue\n                if id_ in ids_:\n                    raise ValueError(f'IDs for contents must be unique. The ID({id_}) already exists in the folder contents')\n                ids_.append(id_)\n        return contents\n\n    def index(self, name_or_id):\n        \"\"\"Get the index of a specific file or folder given the name (or ID).\"\"\"\n        for i, item in enumerate(self.contents):\n            if item.id_ == name_or_id or item.name == name_or_id:\n                return i\n        raise KeyError(f'Name or id_ {name_or_id} not found in contents')\n\n    def __getitem__(self, name_or_id):\n        \"\"\"Get the item by name or id.\"\"\"\n        index = self.index(name_or_id)\n        return self.contents[index]\n\n    def __setitem__(self, name_or_id, value):\n        \"\"\"Set an item by name or id.\"\"\"\n        try:\n            index = self.index(name_or_id)\n            self.contents.pop(index)\n            self.contents.insert(index, value)\n        except KeyError:\n            self.contents.append(value)\n\n    def _repr(self, context=None, indent=0, **kwargs):  # noqa: U100\n        \"\"\"Represent the contents of the folder.\"\"\"\n        indent_ = ' '*indent\n        line_start = f'\\n{indent_}|- '\n        contents_repr = ''\n        if self.contents:\n            contents = sorted(self.contents, key=lambda x: isinstance(x, Folder))\n            lines = [u._repr(context=context, indent=indent+2) for u in contents]\n            contents_repr = ':'+line_start.join(['']+lines)\n        return f'{super()._repr(context=context)}{contents_repr}'\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.__getitem__","title":"<code>__getitem__(name_or_id)</code>","text":"<p>Get the item by name or id.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def __getitem__(self, name_or_id):\n    \"\"\"Get the item by name or id.\"\"\"\n    index = self.index(name_or_id)\n    return self.contents[index]\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.__setitem__","title":"<code>__setitem__(name_or_id, value)</code>","text":"<p>Set an item by name or id.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def __setitem__(self, name_or_id, value):\n    \"\"\"Set an item by name or id.\"\"\"\n    try:\n        index = self.index(name_or_id)\n        self.contents.pop(index)\n        self.contents.insert(index, value)\n    except KeyError:\n        self.contents.append(value)\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.dryrun","title":"<code>dryrun(base_path, context, override_path=None)</code>","text":"<p>Preview the file contents using the context.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def dryrun(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Preview the file contents using the context.\"\"\"\n    folder_path = self.get_path(base_path, context, override_path)\n    contents_dict = {}\n    for u in self.contents:\n        contents_dict.update(u.dryrun(folder_path, context))\n    result = {folder_path: contents_dict}\n    return result\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.index","title":"<code>index(name_or_id)</code>","text":"<p>Get the index of a specific file or folder given the name (or ID).</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def index(self, name_or_id):\n    \"\"\"Get the index of a specific file or folder given the name (or ID).\"\"\"\n    for i, item in enumerate(self.contents):\n        if item.id_ == name_or_id or item.name == name_or_id:\n            return i\n    raise KeyError(f'Name or id_ {name_or_id} not found in contents')\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.validate","title":"<code>validate(base_path, context, override_path=None)</code>","text":"<p>Validate the output against expected.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def validate(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Validate the output against expected.\"\"\"\n    missing = []\n    errors = []\n    ok = []\n    path = self.get_path(base_path, context, override_path)\n    if not path.exists():\n        missing.append(path)\n    for child in self.contents:\n        child_missing, child_errors, child_ok = child.validate(path, context)\n        missing += child_missing\n        errors += child_errors\n        ok += child_ok\n    if not missing and not errors:\n        ok.append(path)\n    return missing, errors, ok\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Folder.write","title":"<code>write(base_path, context, override_path=None)</code>","text":"<p>Write the rendered content to the appropriate path within the <code>base_path</code>.</p> Source code in <code>nskit/mixer/components/folder.py</code> <pre><code>def write(self, base_path: Path, context: Dict[str, Any], override_path: Optional[Path] = None):\n    \"\"\"Write the rendered content to the appropriate path within the ``base_path``.\"\"\"\n    folder_path = self.get_path(base_path, context, override_path)\n    folder_path.mkdir(exist_ok=True, parents=True)\n    contents_dict = {}\n    for obj in self.contents:\n        contents_dict.update(obj.write(folder_path, context))\n    return {folder_path: contents_dict}\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Hook","title":"<code>Hook</code>","text":"<p>             Bases: <code>ABC</code>, <code>BaseModel</code></p> <p>Hook component.</p> Source code in <code>nskit/mixer/components/hook.py</code> <pre><code>class Hook(ABC, BaseModel):\n    \"\"\"Hook component.\"\"\"\n\n    @abstractmethod\n    def call(self, recipe_path: Path, context: Dict[str, Any]) -&gt; Optional[Tuple[str, Path, Dict]]:\n        \"\"\"Return None or tuple (recipe_path, context).\"\"\"\n        raise NotImplementedError()\n\n    def __call__(self, recipe_path: Path, context: Dict[str, Any]) -&gt; Tuple[str, Path, Dict]:\n        \"\"\"Call the hook and return tuple (recipe_path, context).\"\"\"\n        hook_result = self.call(recipe_path, context)\n        if hook_result:\n            recipe_path, context = hook_result\n        return recipe_path, context\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Hook.__call__","title":"<code>__call__(recipe_path, context)</code>","text":"<p>Call the hook and return tuple (recipe_path, context).</p> Source code in <code>nskit/mixer/components/hook.py</code> <pre><code>def __call__(self, recipe_path: Path, context: Dict[str, Any]) -&gt; Tuple[str, Path, Dict]:\n    \"\"\"Call the hook and return tuple (recipe_path, context).\"\"\"\n    hook_result = self.call(recipe_path, context)\n    if hook_result:\n        recipe_path, context = hook_result\n    return recipe_path, context\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Hook.call","title":"<code>call(recipe_path, context)</code>  <code>abstractmethod</code>","text":"<p>Return None or tuple (recipe_path, context).</p> Source code in <code>nskit/mixer/components/hook.py</code> <pre><code>@abstractmethod\ndef call(self, recipe_path: Path, context: Dict[str, Any]) -&gt; Optional[Tuple[str, Path, Dict]]:\n    \"\"\"Return None or tuple (recipe_path, context).\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.LicenseFile","title":"<code>LicenseFile</code>","text":"<p>             Bases: <code>File</code></p> <p>License File created by downloading from Github.</p> Source code in <code>nskit/mixer/components/license_file.py</code> <pre><code>class LicenseFile(File):\n    \"\"\"License File created by downloading from Github.\"\"\"\n\n    name: Optional[Union[TemplateStr, str, Callable]] = Field(get_license_filename, validate_default=True, description='The name of the license file')\n    content: Union[Resource, str, bytes, Path, Callable] = Field(get_license_content, description='The file content')\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.LicenseOptionsEnum","title":"<code>LicenseOptionsEnum</code>","text":"<p>             Bases: <code>Enum</code></p> <p>License Options for the license file.</p> <p>Built from Github API licenses.get_all_commonly_used.</p> Source code in <code>nskit/mixer/components/license_file.py</code> <pre><code>class LicenseOptionsEnum(Enum):\n    \"\"\"License Options for the license file.\n\n    Built from Github API licenses.get_all_commonly_used.\n    \"\"\"\n    AGPL_3_0 = 'agpl-3.0'\n    Apache_2_0 = 'apache-2.0'\n    BSD_2_Clause = 'bsd-2-clause'\n    BSD_3_Clause = 'bsd-3-clause'\n    BSL_1_0 = 'bsl-1.0'\n    CC0_1_0 = 'cc0-1.0'\n    EPL_2_0 = 'epl-2.0'\n    GPL_2_0 = 'gpl-2.0'\n    GPL_3_0 = 'gpl-3.0'\n    LGPL_2_1 = 'lgpl-2.1'\n    MIT = 'mit'\n    MPL_2_0 = 'mpl-2.0'\n    Unlicense = 'unlicense'\n\n    @classmethod\n    def contains(cls, value):\n        \"\"\"Return True if `value` is in `cls`.\n\n        BACKPORT FROM PYTHON 3.12\n\n        `value` is in `cls` if:\n        1) `value` is a member of `cls`, or\n        2) `value` is the value of one of the `cls`'s members.\n        \"\"\"\n        if sys.version_info.major &lt;= 3 and sys.version_info.minor &lt; 12:\n            if isinstance(value, cls):\n                return True\n            try:\n                return value in cls._value2member_map_\n            except TypeError:\n                return value in cls._unhashable_values_\n        return value in cls\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.LicenseOptionsEnum.contains","title":"<code>contains(value)</code>  <code>classmethod</code>","text":"<p>Return True if <code>value</code> is in <code>cls</code>.</p> <p>BACKPORT FROM PYTHON 3.12</p> <p><code>value</code> is in <code>cls</code> if: 1) <code>value</code> is a member of <code>cls</code>, or 2) <code>value</code> is the value of one of the <code>cls</code>'s members.</p> Source code in <code>nskit/mixer/components/license_file.py</code> <pre><code>@classmethod\ndef contains(cls, value):\n    \"\"\"Return True if `value` is in `cls`.\n\n    BACKPORT FROM PYTHON 3.12\n\n    `value` is in `cls` if:\n    1) `value` is a member of `cls`, or\n    2) `value` is the value of one of the `cls`'s members.\n    \"\"\"\n    if sys.version_info.major &lt;= 3 and sys.version_info.minor &lt; 12:\n        if isinstance(value, cls):\n            return True\n        try:\n            return value in cls._value2member_map_\n        except TypeError:\n            return value in cls._unhashable_values_\n    return value in cls\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe","title":"<code>Recipe</code>","text":"<p>             Bases: <code>Folder</code></p> <p>The base Recipe object.</p> <p>A Recipe is a folder, with additional methods for handling context for the Jinja templating. It also includes hooks that can be run before rendering (<code>pre-hooks</code>) e.g. checking or changing values, and after (<code>post-hooks</code>) e.g. running post-generation steps.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>class Recipe(Folder):\n    \"\"\"The base Recipe object.\n\n    A Recipe is a folder, with additional methods for handling context for the Jinja templating.\n    It also includes hooks that can be run before rendering (``pre-hooks``) e.g. checking or changing values,\n    and after (``post-hooks``) e.g. running post-generation steps.\n    \"\"\"\n    name: str = Field(None, validate_default=True, description='The repository name')\n    version: Optional[str] = Field(None, description='The recipe version')  # type: ignore\n    pre_hooks: List[Hook] = Field(\n        default_factory=list,\n        validate_default=True,\n        description='Hooks that can be used to modify a recipe path and context before writing'\n    )\n    post_hooks: List[Hook] = Field(\n        default_factory=list,\n        validate_default=True,\n        description='Hooks that can be used to modify a recipe path and context after writing'\n    )\n    extension_name: Optional[str] = Field(None, description=\"The name of the recipe as an extension to load.\")\n\n    @property\n    def recipe(self):\n        \"\"\"Recipe context.\"\"\"\n        extension_name = self.extension_name\n        if extension_name is None:\n            extension_name = self.__class__.__name__\n        return {'name': f'{self.__class__.__module__}:{self.__class__.__name__}', 'version': self.version, 'extension_name': extension_name}\n\n    def create(self, base_path: Optional[Path] = None, override_path: Optional[Path] = None, **additional_context):\n        \"\"\"Create the recipe.\n\n        Use the configured parameters and any additional context as kwargs to create the recipe at the\n        base path (or current directory if not provided).\n        \"\"\"\n        if base_path is None:\n            base_path = Path.cwd()\n        else:\n            base_path = Path(base_path)\n        context = self.context\n        context.update(additional_context)\n        recipe_path = self.get_path(base_path, context, override_path=override_path)\n        for hook in self.pre_hooks:\n            recipe_path, context = hook(recipe_path, context)\n        content = self.write(recipe_path.parent, context, override_path=recipe_path.name)\n        recipe_path = list(content.keys())[0]\n        for hook in self.post_hooks:\n            recipe_path, context = hook(recipe_path, context)\n        self._write_batch(Path(recipe_path))\n        return {Path(recipe_path): list(content.values())[0]}\n\n    def _write_batch(self, folder_path: Path):\n        \"\"\"Write out the parameters used.\n\n        When we use this we want to keep track of what parameters were used to enable rerunning.\n        This methods writes this into the generated folder as a YAML file.\n        \"\"\"\n        batch_path = Path(folder_path)/'.recipe-batch.yaml'\n        if batch_path.exists():\n            with batch_path.open() as f:\n                batch = yaml.loads(f.read())\n        else:\n            batch = []\n        batch.append(self.recipe_batch)\n        with batch_path.open('w') as f:\n            f.write(yaml.dumps(batch))\n\n    @property\n    def recipe_batch(self):\n        \"\"\"Get information about the specific info of this recipe.\"\"\"\n        if sys.version_info.major &lt;= 3 and sys.version_info.minor &lt; 11:\n            creation_time = dt.datetime.now().astimezone()\n        else:\n            creation_time = dt.datetime.now(dt.UTC).isoformat()\n        return {'context': self.__dump_context(ser=True),\n                'nskit_version': __version__,\n                'creation_time': creation_time,\n                'recipe': self.recipe}\n\n    @property\n    def context(self):\n        \"\"\"Get the context on the initialised recipe.\"\"\"\n        # This inherits (via FileSystemObject) from nskit.common.configuration:BaseConfiguration, which includes properties in model dumps\n        return self.__dump_context()\n\n    def __dump_context(self, ser=False):\n        # Make sure it is serialisable if required\n        if ser:\n            mode = 'json'\n        else:\n            mode = 'python'\n        context = self.model_dump(\n            mode=mode,\n            exclude={\n                'context',\n                'contents',\n                'name',\n                'id_',\n                'post_hooks',\n                'pre_hooks',\n                'version',\n                'recipe_batch',\n                'recipe',\n                'extension_name',\n                }\n            )\n        context.update({'recipe': self.recipe})\n        return context\n\n    def __repr__(self):\n        \"\"\"Repr(x) == x.__repr__.\"\"\"\n        context = self.context\n        return f'{self._repr(context=context)}\\n\\nContext: {context}'\n\n    def dryrun(\n            self,\n            base_path: Optional[Path] = None,\n            override_path: Optional[Path] = None,\n            **additional_context):\n        \"\"\"See the recipe as a dry run.\"\"\"\n        combined_context = self.context\n        combined_context.update(additional_context)\n        if base_path is None:\n            base_path = Path.cwd()\n        return super().dryrun(base_path=base_path, context=combined_context, override_path=override_path)\n\n    def validate(\n            self,\n            base_path: Optional[Path] = None,\n            override_path: Optional[Path] = None,\n            **additional_context):\n        \"\"\"Validate the created repo.\"\"\"\n        combined_context = self.context\n        combined_context.update(additional_context)\n        if base_path is None:\n            base_path = Path.cwd()\n        return super().validate(base_path=base_path, context=combined_context, override_path=override_path)\n\n    @staticmethod\n    def load(recipe_name: str, **kwargs):\n        \"\"\"Load a recipe as an extension.\"\"\"\n        recipe_klass = load_extension(RECIPE_ENTRYPOINT, recipe_name)\n        if recipe_klass is None:\n            raise ValueError(f'Recipe {recipe_name} not found, it may be mis-spelt or not installed. Available recipes: {get_extension_names(RECIPE_ENTRYPOINT)}')\n        recipe = recipe_klass(**kwargs)\n        recipe.extension_name = recipe_name\n        return recipe\n\n    @staticmethod\n    def inspect(recipe_name: str, include_private: bool = False, include_folder: bool = False, include_base: bool = False):\n        \"\"\"Get the fields on a recipe as an extension.\"\"\"\n        recipe_klass = load_extension(RECIPE_ENTRYPOINT, recipe_name)\n        if recipe_klass is None:\n            raise ValueError(f'Recipe {recipe_name} not found, it may be mis-spelt or not installed. Available recipes: {get_extension_names(RECIPE_ENTRYPOINT)}')\n        sig = Recipe._inspect_basemodel(recipe_klass, include_private=include_private)\n        if not include_folder:\n            folder_sig = inspect.signature(Folder)\n            params = [v for u, v in sig.parameters.items() if u not in folder_sig.parameters.keys() or u == 'name']\n            sig = sig.replace(parameters=params)\n        if not include_base:\n            recipe_sig = inspect.signature(Recipe)\n            params = [v for u, v in sig.parameters.items() if u not in recipe_sig.parameters.keys() or u == 'name']\n            sig = sig.replace(parameters=params)\n        return sig\n\n    @staticmethod\n    def _inspect_basemodel(kls, include_private: bool = False):\n        sig = inspect.signature(kls)\n        # we need to drop the private params\n        params = []\n        for u, v in sig.parameters.items():\n            if not include_private and u.startswith('_'):\n                continue\n            if isinstance(v.annotation, type) and issubclass(v.annotation, BaseModel):\n                params.append(v.replace(default=Recipe._inspect_basemodel(v.annotation, include_private=include_private)))\n            else:\n                params.append(v)\n        return sig.replace(parameters=params, return_annotation=kls)\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.context","title":"<code>context</code>  <code>property</code>","text":"<p>Get the context on the initialised recipe.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.recipe","title":"<code>recipe</code>  <code>property</code>","text":"<p>Recipe context.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.recipe_batch","title":"<code>recipe_batch</code>  <code>property</code>","text":"<p>Get information about the specific info of this recipe.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr(x) == x.repr.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr(x) == x.__repr__.\"\"\"\n    context = self.context\n    return f'{self._repr(context=context)}\\n\\nContext: {context}'\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.create","title":"<code>create(base_path=None, override_path=None, **additional_context)</code>","text":"<p>Create the recipe.</p> <p>Use the configured parameters and any additional context as kwargs to create the recipe at the base path (or current directory if not provided).</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def create(self, base_path: Optional[Path] = None, override_path: Optional[Path] = None, **additional_context):\n    \"\"\"Create the recipe.\n\n    Use the configured parameters and any additional context as kwargs to create the recipe at the\n    base path (or current directory if not provided).\n    \"\"\"\n    if base_path is None:\n        base_path = Path.cwd()\n    else:\n        base_path = Path(base_path)\n    context = self.context\n    context.update(additional_context)\n    recipe_path = self.get_path(base_path, context, override_path=override_path)\n    for hook in self.pre_hooks:\n        recipe_path, context = hook(recipe_path, context)\n    content = self.write(recipe_path.parent, context, override_path=recipe_path.name)\n    recipe_path = list(content.keys())[0]\n    for hook in self.post_hooks:\n        recipe_path, context = hook(recipe_path, context)\n    self._write_batch(Path(recipe_path))\n    return {Path(recipe_path): list(content.values())[0]}\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.dryrun","title":"<code>dryrun(base_path=None, override_path=None, **additional_context)</code>","text":"<p>See the recipe as a dry run.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def dryrun(\n        self,\n        base_path: Optional[Path] = None,\n        override_path: Optional[Path] = None,\n        **additional_context):\n    \"\"\"See the recipe as a dry run.\"\"\"\n    combined_context = self.context\n    combined_context.update(additional_context)\n    if base_path is None:\n        base_path = Path.cwd()\n    return super().dryrun(base_path=base_path, context=combined_context, override_path=override_path)\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.inspect","title":"<code>inspect(recipe_name, include_private=False, include_folder=False, include_base=False)</code>  <code>staticmethod</code>","text":"<p>Get the fields on a recipe as an extension.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>@staticmethod\ndef inspect(recipe_name: str, include_private: bool = False, include_folder: bool = False, include_base: bool = False):\n    \"\"\"Get the fields on a recipe as an extension.\"\"\"\n    recipe_klass = load_extension(RECIPE_ENTRYPOINT, recipe_name)\n    if recipe_klass is None:\n        raise ValueError(f'Recipe {recipe_name} not found, it may be mis-spelt or not installed. Available recipes: {get_extension_names(RECIPE_ENTRYPOINT)}')\n    sig = Recipe._inspect_basemodel(recipe_klass, include_private=include_private)\n    if not include_folder:\n        folder_sig = inspect.signature(Folder)\n        params = [v for u, v in sig.parameters.items() if u not in folder_sig.parameters.keys() or u == 'name']\n        sig = sig.replace(parameters=params)\n    if not include_base:\n        recipe_sig = inspect.signature(Recipe)\n        params = [v for u, v in sig.parameters.items() if u not in recipe_sig.parameters.keys() or u == 'name']\n        sig = sig.replace(parameters=params)\n    return sig\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.load","title":"<code>load(recipe_name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load a recipe as an extension.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>@staticmethod\ndef load(recipe_name: str, **kwargs):\n    \"\"\"Load a recipe as an extension.\"\"\"\n    recipe_klass = load_extension(RECIPE_ENTRYPOINT, recipe_name)\n    if recipe_klass is None:\n        raise ValueError(f'Recipe {recipe_name} not found, it may be mis-spelt or not installed. Available recipes: {get_extension_names(RECIPE_ENTRYPOINT)}')\n    recipe = recipe_klass(**kwargs)\n    recipe.extension_name = recipe_name\n    return recipe\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.Recipe.validate","title":"<code>validate(base_path=None, override_path=None, **additional_context)</code>","text":"<p>Validate the created repo.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def validate(\n        self,\n        base_path: Optional[Path] = None,\n        override_path: Optional[Path] = None,\n        **additional_context):\n    \"\"\"Validate the created repo.\"\"\"\n    combined_context = self.context\n    combined_context.update(additional_context)\n    if base_path is None:\n        base_path = Path.cwd()\n    return super().validate(base_path=base_path, context=combined_context, override_path=override_path)\n</code></pre>"},{"location":"api/nskit.mixer/#nskitmixercomponentslicense_file","title":"nskit.mixer.components.license_file","text":"<p>License file handler.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.components.license_file.get_license_filename","title":"<code>get_license_filename(context=None)</code>","text":"<p>Callable to set the default license file name.</p> Source code in <code>nskit/mixer/components/license_file.py</code> <pre><code>def get_license_filename(context: Optional[Dict[str, Any]] = None):\n    \"\"\"Callable to set the default license file name.\"\"\"\n    # Can't do in LicenseOptionsEnum pre 3.12\n    if LicenseOptionsEnum.contains(context.get('license', None)):\n        # Handle naming\n        license_name = LicenseOptionsEnum(context.get('license', None))\n        # COPYING\n        if license_name in [\n            LicenseOptionsEnum.AGPL_3_0,\n            LicenseOptionsEnum.GPL_2_0,\n            LicenseOptionsEnum.GPL_3_0,\n        ]:\n            name = 'COPYING'\n        # COPYING.LESSER\n        elif license_name in [\n            LicenseOptionsEnum.LGPL_2_1,\n        ]:\n            name = 'COPYING.LESSER'\n        # LICENSE\n        elif license_name in [\n            LicenseOptionsEnum.MIT,\n            LicenseOptionsEnum.Apache_2_0,\n            LicenseOptionsEnum.BSD_2_Clause,\n            LicenseOptionsEnum.BSD_3_Clause,\n            LicenseOptionsEnum.BSL_1_0,\n            LicenseOptionsEnum.CC0_1_0,\n            LicenseOptionsEnum.EPL_2_0,\n            LicenseOptionsEnum.MIT,\n            LicenseOptionsEnum.MPL_2_0\n        ]:\n            name = \"LICENSE\"\n        # UNLICENSE\n        elif license_name in [LicenseOptionsEnum.Unlicense]:\n            name = 'UNLICENSE'\n        return name\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.components.license_file.get_license_content","title":"<code>get_license_content(context)</code>","text":"<p>Render the content of the license.</p> Source code in <code>nskit/mixer/components/license_file.py</code> <pre><code>def get_license_content(context: Dict[str, Any]):\n    \"\"\"Render the content of the license.\"\"\"\n    # We implement some specifics based on the implementation instructions in Github licenses api get\n    # Can't do in LicenseOptionsEnum pre 3.12\n    if LicenseOptionsEnum.contains(context.get('license', None)):\n        license_name = LicenseOptionsEnum(context.get('license', None))\n        license_content = _get_license_content(license_name)\n        content = license_content.body\n        # [year] [fullname] to be replaced\n        if license_name in [\n            LicenseOptionsEnum.BSD_2_Clause,\n            LicenseOptionsEnum.BSD_3_Clause,\n            LicenseOptionsEnum.MIT,\n        ]:\n            content = content.replace('[year]', '{{license_year}}').replace('[fullname]', '{{repo.name}} Developers')\n        context['license_year'] = context.get('license_year', date.today().year)\n        return content\n</code></pre>"},{"location":"api/nskit.mixer/#nskitmixerrepo","title":"nskit.mixer.repo","text":"<p>A base recipe object for a code (git) repo.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.repo.CodeRecipe","title":"<code>CodeRecipe</code>","text":"<p>             Bases: <code>Recipe</code></p> <p>Recipe for a code repo.</p> <p>Includes default git init and precommit install hooks.</p> Source code in <code>nskit/mixer/repo.py</code> <pre><code>class CodeRecipe(Recipe):\n    \"\"\"Recipe for a code repo.\n\n    Includes default git init and precommit install hooks.\n    \"\"\"\n    repo: RepoMetadata\n    post_hooks: Optional[List[Callable]] = Field(\n        [hooks.git.GitInit(), hooks.pre_commit.PrecommitInstall()],\n        validate_default=True,\n        description='Hooks that can be used to modify a recipe path and context after writing'\n    )\n    git: GitConfig = GitConfig()\n    language: str = 'python'\n    license: Optional[LicenseOptionsEnum] = None\n\n    def get_pipeline_filenames(self):\n        \"\"\"Get CICD Pipeline filenames.\"\"\"\n        return []\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.repo.CodeRecipe.get_pipeline_filenames","title":"<code>get_pipeline_filenames()</code>","text":"<p>Get CICD Pipeline filenames.</p> Source code in <code>nskit/mixer/repo.py</code> <pre><code>def get_pipeline_filenames(self):\n    \"\"\"Get CICD Pipeline filenames.\"\"\"\n    return []\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.repo.RepoMetadata","title":"<code>RepoMetadata</code>","text":"<p>             Bases: <code>BaseConfiguration</code></p> <p>Repository/package metadata information.</p> Source code in <code>nskit/mixer/repo.py</code> <pre><code>class RepoMetadata(BaseConfiguration):\n    \"\"\"Repository/package metadata information.\"\"\"\n\n    repo_separator: str = '-'\n    owner: str = Field(..., description=\"Who is the owner of the repo\")\n    email: EmailStr = Field(..., description=\"The email for the repo owner\")\n    description: str = Field('', description=\"A summary description for the repo\")\n    url: HttpUrl = Field(..., description='The Repository url.')\n</code></pre>"},{"location":"api/nskit.mixer/#nskitmixerhooks","title":"nskit.mixer.hooks","text":"<p>Common hooks.</p>"},{"location":"api/nskit.mixer/#nskitmixerhooksgit","title":"nskit.mixer.hooks.git","text":"<p>Git hooks.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.hooks.git.GitInit","title":"<code>GitInit</code>","text":"<p>             Bases: <code>Hook</code></p> <p>Git Hook to (re) initialise a repo.</p> Source code in <code>nskit/mixer/hooks/git.py</code> <pre><code>class GitInit(Hook):\n    \"\"\"Git Hook to (re) initialise a repo.\"\"\"\n\n    def call(self, recipe_path: Path, context: Dict[str, Any]):\n        \"\"\"(re)initialise the repo.\"\"\"\n        with ChDir(recipe_path):\n            logger.info('Initialising git repo')\n            try:\n                initial_branch_name = subprocess.check_output(['git', 'config', '--get', 'init.defaultBranch']).decode()  # nosec B607, B603\n            except subprocess.CalledProcessError:\n                initial_branch_name = None\n            if not initial_branch_name:\n                initial_branch_name = 'main'\n            initial_branch_name = context.get('git', {}).get('initial_branch_name', initial_branch_name)\n            # Check git version - new versions have --initial-branch arg on init\n            version = subprocess.check_output(['git', 'version']).decode()  # nosec B607, B603\n            version = version.replace('git version', '').lstrip()\n            semver = parse('.'.join(version.split(' ')[0].split('.')[:3]))\n            if semver &gt;= parse('2.28.0'):\n                subprocess.check_call(['git', 'init', '--initial-branch', initial_branch_name])  # nosec B607, B603\n            else:\n                subprocess.check_call(['git', 'init'])  # nosec B607, B603\n                subprocess.check_call(['git', 'checkout', '-B', initial_branch_name])  # nosec B607, B603\n            logger.info('Done')\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.hooks.git.GitInit.call","title":"<code>call(recipe_path, context)</code>","text":"<p>(re)initialise the repo.</p> Source code in <code>nskit/mixer/hooks/git.py</code> <pre><code>def call(self, recipe_path: Path, context: Dict[str, Any]):\n    \"\"\"(re)initialise the repo.\"\"\"\n    with ChDir(recipe_path):\n        logger.info('Initialising git repo')\n        try:\n            initial_branch_name = subprocess.check_output(['git', 'config', '--get', 'init.defaultBranch']).decode()  # nosec B607, B603\n        except subprocess.CalledProcessError:\n            initial_branch_name = None\n        if not initial_branch_name:\n            initial_branch_name = 'main'\n        initial_branch_name = context.get('git', {}).get('initial_branch_name', initial_branch_name)\n        # Check git version - new versions have --initial-branch arg on init\n        version = subprocess.check_output(['git', 'version']).decode()  # nosec B607, B603\n        version = version.replace('git version', '').lstrip()\n        semver = parse('.'.join(version.split(' ')[0].split('.')[:3]))\n        if semver &gt;= parse('2.28.0'):\n            subprocess.check_call(['git', 'init', '--initial-branch', initial_branch_name])  # nosec B607, B603\n        else:\n            subprocess.check_call(['git', 'init'])  # nosec B607, B603\n            subprocess.check_call(['git', 'checkout', '-B', initial_branch_name])  # nosec B607, B603\n        logger.info('Done')\n</code></pre>"},{"location":"api/nskit.mixer/#nskitmixerhookspre_commit","title":"nskit.mixer.hooks.pre_commit","text":"<p>Precommit hooks.</p> <p>Contains post creation precommit install hooks.</p>"},{"location":"api/nskit.mixer/#nskit.mixer.hooks.pre_commit.PrecommitInstall","title":"<code>PrecommitInstall</code>","text":"<p>             Bases: <code>Hook</code></p> <p>Precommit install hook.</p> Source code in <code>nskit/mixer/hooks/pre_commit.py</code> <pre><code>class PrecommitInstall(Hook):\n    \"\"\"Precommit install hook.\"\"\"\n\n    def call(self, recipe_path: Path, context: Dict[str, Any]):  # noqa: U100\n        \"\"\"Run the pre-commit install and install hooks command.\"\"\"\n        with ChDir(recipe_path):\n            if Path('.pre-commit-config.yaml').exists():\n                logger.info('Installing precommit')\n                # Install if pre-commit installed\n                subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pre-commit'])  # nosec B603\n                logger.info('Installing hooks')\n                with open('.pre-commit-config.yaml') as f:\n                    logger.info(f'Precommit Config: {f.read()}')\n                # Run\n                try:\n                    subprocess.check_output([sys.executable, '-m', 'pre_commit', 'install', '--install-hooks'])  # nosec B603\n                except subprocess.CalledProcessError as e:\n                    logger.error('Error running pre-commit', output=e.output, return_code=e.returncode)\n                    raise e from None\n                logger.info('Done')\n            else:\n                logger.info('Precommit config file not detected, skipping.')\n</code></pre>"},{"location":"api/nskit.mixer/#nskit.mixer.hooks.pre_commit.PrecommitInstall.call","title":"<code>call(recipe_path, context)</code>","text":"<p>Run the pre-commit install and install hooks command.</p> Source code in <code>nskit/mixer/hooks/pre_commit.py</code> <pre><code>def call(self, recipe_path: Path, context: Dict[str, Any]):  # noqa: U100\n    \"\"\"Run the pre-commit install and install hooks command.\"\"\"\n    with ChDir(recipe_path):\n        if Path('.pre-commit-config.yaml').exists():\n            logger.info('Installing precommit')\n            # Install if pre-commit installed\n            subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pre-commit'])  # nosec B603\n            logger.info('Installing hooks')\n            with open('.pre-commit-config.yaml') as f:\n                logger.info(f'Precommit Config: {f.read()}')\n            # Run\n            try:\n                subprocess.check_output([sys.executable, '-m', 'pre_commit', 'install', '--install-hooks'])  # nosec B603\n            except subprocess.CalledProcessError as e:\n                logger.error('Error running pre-commit', output=e.output, return_code=e.returncode)\n                raise e from None\n            logger.info('Done')\n        else:\n            logger.info('Precommit config file not detected, skipping.')\n</code></pre>"},{"location":"api/nskit.recipes/","title":"nskit.recipes","text":"<p>Recipes for the mixer, using entrypoints to make them available.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.recipe.RecipeRecipe","title":"<code>nskit.recipes.recipe.RecipeRecipe</code>","text":"<p>             Bases: <code>PyRecipe</code></p> <p>A Recipe for creating Recipes, meta!</p> Source code in <code>nskit/recipes/recipe.py</code> <pre><code>class RecipeRecipe(PyRecipe):\n    \"\"\"A Recipe for creating Recipes, meta!\"\"\"\n\n    contents: List[Union[File, Folder]] = Field(\n        [\n            ingredients.gitignore,\n            ingredients.noxfile,\n            ingredients.pre_commit,\n            recipe_ingredients.pyproject_toml,\n            recipe_ingredients.readme_md,\n            ingredients.test_dir,\n            recipe_ingredients.src_dir,\n            ingredients.docs_dir,\n            LicenseFile()\n        ],\n        description='The folder contents')\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.recipe.RecipeRecipe.contents","title":"<code>contents: List[Union[File, Folder]] = Field([ingredients.gitignore, ingredients.noxfile, ingredients.pre_commit, recipe_ingredients.pyproject_toml, recipe_ingredients.readme_md, ingredients.test_dir, recipe_ingredients.src_dir, ingredients.docs_dir, LicenseFile()], description='The folder contents')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.api.APIRecipe","title":"<code>nskit.recipes.python.api.APIRecipe</code>","text":"<p>             Bases: <code>PyRecipe</code></p> <p>API Service Recipe.</p> Source code in <code>nskit/recipes/python/api.py</code> <pre><code>class APIRecipe(PyRecipe):\n    \"\"\"API Service Recipe.\"\"\"\n\n    contents: List[Union[File, Folder]] = Field(\n        [\n            ingredients.gitignore,\n            ingredients.noxfile,\n            ingredients.pre_commit,\n            api_ingredients.pyproject_toml,\n            api_ingredients.readme_md,\n            ingredients.test_dir,\n            api_ingredients.src_dir,\n            api_ingredients.docker.dockerignore,\n            api_ingredients.docker.api_dockerfile,\n            ingredients.docs_dir,\n            LicenseFile()\n        ],\n        description='The folder contents')\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.api.APIRecipe.contents","title":"<code>contents: List[Union[File, Folder]] = Field([ingredients.gitignore, ingredients.noxfile, ingredients.pre_commit, api_ingredients.pyproject_toml, api_ingredients.readme_md, ingredients.test_dir, api_ingredients.src_dir, api_ingredients.docker.dockerignore, api_ingredients.docker.api_dockerfile, ingredients.docs_dir, LicenseFile()], description='The folder contents')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.package.PackageRecipe","title":"<code>nskit.recipes.python.package.PackageRecipe</code>","text":"<p>             Bases: <code>PyRecipe</code></p> <p>Package Recipe.</p> Source code in <code>nskit/recipes/python/package.py</code> <pre><code>class PackageRecipe(PyRecipe):\n    \"\"\"Package Recipe.\"\"\"\n\n    contents: List[Union[File, Folder]] = Field(\n        [\n            ingredients.gitignore,\n            ingredients.noxfile,\n            ingredients.pre_commit,\n            ingredients.pyproject_toml,\n            ingredients.readme_md,\n            ingredients.test_dir,\n            ingredients.src_dir,\n            ingredients.docs_dir,\n            LicenseFile()\n        ],\n        description='The folder contents')\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.package.PackageRecipe.contents","title":"<code>contents: List[Union[File, Folder]] = Field([ingredients.gitignore, ingredients.noxfile, ingredients.pre_commit, ingredients.pyproject_toml, ingredients.readme_md, ingredients.test_dir, ingredients.src_dir, ingredients.docs_dir, LicenseFile()], description='The folder contents')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#python-ingredients","title":"Python Ingredients","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe","title":"<code>nskit.recipes.python.PyRecipe</code>","text":"<p>             Bases: <code>CodeRecipe</code></p> <p>Base recipe for python recipes.</p> Source code in <code>nskit/recipes/python/__init__.py</code> <pre><code>class PyRecipe(CodeRecipe):\n    \"\"\"Base recipe for python recipes.\"\"\"\n\n    version: str = __version__\n    \"\"\"Version of the recipe.\"\"\"\n\n    repo: PyRepoMetadata = Field(...)\n    \"\"\"Python repo metadata.\"\"\"\n\n    @staticmethod\n    def _to_pep8(value):\n        return str(value).lower().replace(' ', '_').replace('-', '_')\n\n    def model_post_init(self, *args):  # noqa: U100\n        \"\"\"Set repo name handling.\"\"\"\n        self.repo.name = self.name\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.name","title":"<code>name: str = Field(None, validate_default=True, description='The repository name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.version","title":"<code>version: str = __version__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Version of the recipe.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.repo","title":"<code>repo: PyRepoMetadata = Field(...)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Python repo metadata.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.pre_hooks","title":"<code>pre_hooks: List[Hook] = Field(default_factory=list, validate_default=True, description='Hooks that can be used to modify a recipe path and context before writing')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.post_hooks","title":"<code>post_hooks: Optional[List[Callable]] = Field([hooks.git.GitInit(), hooks.pre_commit.PrecommitInstall()], validate_default=True, description='Hooks that can be used to modify a recipe path and context after writing')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.extension_name","title":"<code>extension_name: Optional[str] = Field(None, description='The name of the recipe as an extension to load.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.git","title":"<code>git: GitConfig = GitConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.context","title":"<code>context</code>  <code>property</code>","text":"<p>Get the context on the initialised recipe.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.recipe_batch","title":"<code>recipe_batch</code>  <code>property</code>","text":"<p>Get information about the specific info of this recipe.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.dryrun","title":"<code>dryrun(base_path=None, override_path=None, **additional_context)</code>","text":"<p>See the recipe as a dry run.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def dryrun(\n        self,\n        base_path: Optional[Path] = None,\n        override_path: Optional[Path] = None,\n        **additional_context):\n    \"\"\"See the recipe as a dry run.\"\"\"\n    combined_context = self.context\n    combined_context.update(additional_context)\n    if base_path is None:\n        base_path = Path.cwd()\n    return super().dryrun(base_path=base_path, context=combined_context, override_path=override_path)\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.validate","title":"<code>validate(base_path=None, override_path=None, **additional_context)</code>","text":"<p>Validate the created repo.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def validate(\n        self,\n        base_path: Optional[Path] = None,\n        override_path: Optional[Path] = None,\n        **additional_context):\n    \"\"\"Validate the created repo.\"\"\"\n    combined_context = self.context\n    combined_context.update(additional_context)\n    if base_path is None:\n        base_path = Path.cwd()\n    return super().validate(base_path=base_path, context=combined_context, override_path=override_path)\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.create","title":"<code>create(base_path=None, override_path=None, **additional_context)</code>","text":"<p>Create the recipe.</p> <p>Use the configured parameters and any additional context as kwargs to create the recipe at the base path (or current directory if not provided).</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>def create(self, base_path: Optional[Path] = None, override_path: Optional[Path] = None, **additional_context):\n    \"\"\"Create the recipe.\n\n    Use the configured parameters and any additional context as kwargs to create the recipe at the\n    base path (or current directory if not provided).\n    \"\"\"\n    if base_path is None:\n        base_path = Path.cwd()\n    else:\n        base_path = Path(base_path)\n    context = self.context\n    context.update(additional_context)\n    recipe_path = self.get_path(base_path, context, override_path=override_path)\n    for hook in self.pre_hooks:\n        recipe_path, context = hook(recipe_path, context)\n    content = self.write(recipe_path.parent, context, override_path=recipe_path.name)\n    recipe_path = list(content.keys())[0]\n    for hook in self.post_hooks:\n        recipe_path, context = hook(recipe_path, context)\n    self._write_batch(Path(recipe_path))\n    return {Path(recipe_path): list(content.values())[0]}\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRecipe.load","title":"<code>load(recipe_name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load a recipe as an extension.</p> Source code in <code>nskit/mixer/components/recipe.py</code> <pre><code>@staticmethod\ndef load(recipe_name: str, **kwargs):\n    \"\"\"Load a recipe as an extension.\"\"\"\n    recipe_klass = load_extension(RECIPE_ENTRYPOINT, recipe_name)\n    if recipe_klass is None:\n        raise ValueError(f'Recipe {recipe_name} not found, it may be mis-spelt or not installed. Available recipes: {get_extension_names(RECIPE_ENTRYPOINT)}')\n    recipe = recipe_klass(**kwargs)\n    recipe.extension_name = recipe_name\n    return recipe\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata","title":"<code>nskit.recipes.python.PyRepoMetadata</code>","text":"<p>             Bases: <code>RepoMetadata</code></p> <p>Repo Metadata for python templates.</p> Source code in <code>nskit/recipes/python/__init__.py</code> <pre><code>class PyRepoMetadata(RepoMetadata):\n    \"\"\"Repo Metadata for python templates.\"\"\"\n\n    _name: str = None\n\n    @property\n    def name(self):\n        \"\"\"Get repo name.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        \"\"\"Set repo name.\"\"\"\n        if isinstance(value, str):\n            self._name = value\n\n    def _get_name_parts(self):\n        return re.split('|'.join(map(re.escape, list(set(_DELIMITERS+[self.repo_separator])))), self.name)\n\n    @property\n    def py_name(self):\n        \"\"\"Get python module name.\"\"\"\n        return '.'.join(self._get_name_parts())\n\n    @property\n    def py_root(self):\n        \"\"\"Get root python module name.\"\"\"\n        return self._get_name_parts()[0]\n\n    @property\n    def src_path(self):\n        \"\"\"Get module folder structure (src not included).\"\"\"\n        return Path(*self._get_name_parts()).as_posix()\n\n    @property\n    def module_depth(self) -&gt; int:\n        \"\"\"Get the module depth.\n\n        ``a.b.c`` has a depth of 3, ``a`` has a depth of 1\n        \"\"\"\n        return len(self._get_name_parts())\n</code></pre>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.owner","title":"<code>owner: str = Field(..., description='Who is the owner of the repo')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.email","title":"<code>email: EmailStr = Field(..., description='The email for the repo owner')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.url","title":"<code>url: HttpUrl = Field(..., description='The Repository url.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Get repo name.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.py_name","title":"<code>py_name</code>  <code>property</code>","text":"<p>Get python module name.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.py_root","title":"<code>py_root</code>  <code>property</code>","text":"<p>Get root python module name.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.src_path","title":"<code>src_path</code>  <code>property</code>","text":"<p>Get module folder structure (src not included).</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.PyRepoMetadata.module_depth","title":"<code>module_depth: int</code>  <code>property</code>","text":"<p>Get the module depth.</p> <p><code>a.b.c</code> has a depth of 3, <code>a</code> has a depth of 1</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients","title":"<code>nskit.recipes.python.ingredients</code>","text":"<p>Ingredients for repos.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.gitignore","title":"<code>gitignore = File(name='.gitignore', content='nskit.recipes.python.ingredients:gitignore.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.noxfile","title":"<code>noxfile = File(name='noxfile.py', content='nskit.recipes.python.ingredients:noxfile.py.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.pre_commit","title":"<code>pre_commit = File(name='.pre-commit-config.yaml', content='nskit.recipes.python.ingredients:pre-commit-config.yaml.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.pyproject_toml","title":"<code>pyproject_toml = File(name='pyproject.toml', content='nskit.recipes.python.ingredients:pyproject.toml.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.readme_md","title":"<code>readme_md = File(name='README.md', content='nskit.recipes.python.ingredients:readme.md.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.test_dir","title":"<code>test_dir = Folder(name='tests', contents=[Folder(name='unit', contents=[File(name='test_placeholder.py', content=test_placeholder)]), Folder(name='functional', contents=[File(name='.git-keep', content='')])])</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.src_dir","title":"<code>src_dir = Folder(name='src', contents=[Folder(id_='src_path', name='{{repo.src_path}}', contents=[File(name='__init__.py', content='nskit.recipes.python.ingredients:__init__.py.template')])])</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api","title":"<code>nskit.recipes.python.ingredients.api</code>","text":"<p>API Service ingredients.</p> <p>Contains fastapi based api service ingredients.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api.pyproject_toml","title":"<code>pyproject_toml = File(name='pyproject.toml', content='nskit.recipes.python.ingredients.api:pyproject.toml.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api.readme_md","title":"<code>readme_md = File(name='README.md', content='nskit.recipes.python.ingredients.api:readme.md.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#src_dir","title":"<code>src_dir</code>","text":"<p>Adds <code>app.py</code>, <code>auth.py</code>, <code>server.py</code>, <code>api/__init__.py</code>, <code>base.py</code> to [nskit.recipes.python.ingredients.src_dir]</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api.docker","title":"<code>nskit.recipes.python.ingredients.api.docker</code>","text":"<p>Docker ingredients.</p> <p>Contains dockerfile, .dockerignore files.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api.docker.api_dockerfile","title":"<code>api_dockerfile = File(name='Dockerfile', content='nskit.recipes.python.ingredients.api.docker:api.Dockerfile.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.api.docker.dockerignore","title":"<code>dockerignore = File(name='.dockerignore', content='nskit.recipes.python.ingredients.api.docker:dockerignore.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.recipe","title":"<code>nskit.recipes.python.ingredients.recipe</code>","text":"<p>Ingredients for a recipe recipe.</p>"},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.recipe.pyproject_toml","title":"<code>pyproject_toml = File(name='pyproject.toml', content='nskit.recipes.python.ingredients.recipe:pyproject.toml.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#nskit.recipes.python.ingredients.recipe.readme_md","title":"<code>readme_md = File(name='README.md', content='nskit.recipes.python.ingredients.recipe:readme.md.template')</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.recipes/#src_dir_1","title":"<code>src_dir</code>","text":"<p>Adds <code>recipe.py</code> and <code>ingredient.py.template</code> to [nskit.recipes.python.ingredients.src_dir]</p>"},{"location":"api/nskit.vcs/","title":"nskit.vcs","text":"<p>VCS and Codebase handlers for creating repo (and build) infrastructure.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.NamespaceOptionsType","title":"<code>NamespaceOptionsType = TypeAliasType('NamespaceOptionsType', List[Union[str, Dict[str, 'NamespaceOptionsType']]])</code>  <code>module-attribute</code>","text":""},{"location":"api/nskit.vcs/#nskit.vcs.Codebase","title":"<code>Codebase</code>","text":"<p>             Bases: <code>BaseConfiguration</code></p> <p>Object for managing a codebase.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>class Codebase(BaseConfiguration):\n    \"\"\"Object for managing a codebase.\"\"\"\n    root_dir: Path = Field(default_factory=Path.cwd)\n    settings: Annotated[CodebaseSettings, Field(validate_default=True)] = None\n    namespaces_dir: Path = Path('.namespaces')\n    namespace_validation_repo: Optional[NamespaceValidationRepo] = None\n\n    @field_validator('settings', mode='before')\n    @classmethod\n    def _validate_settings(cls, value):\n        if value is None:\n            value = CodebaseSettings()\n        return value\n\n    @field_validator('namespace_validation_repo', mode='before')\n    @classmethod\n    def _validate_namespace_validation_repo_from_settings(cls, value, info: ValidationInfo):\n        if value is None:\n            try:\n                value = info.data.get('settings').namespace_validation_repo\n            except (AttributeError) as e:\n                raise ValueError(e) from None\n        return value\n\n    @field_validator('namespace_validation_repo', mode='after')\n    @classmethod\n    def _validate_namespace_validation_repo(cls, value, info: ValidationInfo):\n        if value:\n            value.local_dir = info.data.get('root_dir')/info.data.get('namespaces_dir')\n        return value\n\n    def model_post_init(self, *args, **kwargs):\n        \"\"\"Set the settings namespace validation repo to the same as the codebase.\"\"\"\n        super().model_post_init(*args, **kwargs)\n        self.settings.namespace_validation_repo = self.namespace_validation_repo\n\n    @property\n    def namespace_validator(self):\n        \"\"\"Get the namespace validator object.\"\"\"\n        if self.namespace_validation_repo:\n            return self.namespace_validation_repo.validator\n        else:\n            return NamespaceValidator(options=None)\n\n    def list_repos(self):\n        \"\"\"Get the repo names that are validated by the namespace_validator if provided.\"\"\"\n        potential_repos = self.settings.provider_settings.repo_client.list()\n        sdk_repos = []\n        for repo in potential_repos:\n            result, _ = self.namespace_validator.validate_name(repo)\n            if result:\n                sdk_repos.append(repo)\n        return sdk_repos\n\n    def clone(self):\n        \"\"\"Clone all repos that match the codebase to a local (nested) directory.\"\"\"\n        # List repos\n        root = self.root_dir\n        root.mkdir(exist_ok=True, parents=True)\n        repos = self.list_repos()\n        # Create folder structure based on namespacing\n        cloned = []\n        for repo in repos:\n            repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(repo))\n            r = Repo(\n                name=repo,\n                local_dir=repo_dir,\n                namespace_validation_repo=self.namespace_validation_repo,\n                validation_level=self.settings.validation_level,\n                provider_client=self.settings.provider_settings.repo_client)\n            if not r.exists_locally:\n                r.clone()\n            r.install(codebase=self, deps=False)\n            cloned.append(r)\n        # Once installed all with no deps, install deps again\n        for repo in cloned:\n            repo.install(codebase=self, deps=True)\n        return cloned\n\n    def create_repo(self, name, with_recipe: Optional[str] = None, **recipe_kwargs):\n        \"\"\"Create a repo in the codebase.\n\n        with_recipe will instantiate it with a specific recipe - the kwargs need to be provided to the call.\n        \"\"\"\n        repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(name))\n        r = Repo(\n            name=name,\n            local_dir=repo_dir,\n            namespace_validation_repo=self.namespace_validation_repo,\n            validation_level=self.settings.validation_level,\n            provider_client=self.settings.provider_settings.repo_client)\n        if r.exists or r.exists_locally:\n            raise ValueError(f'Repo {name} already exists')\n        r.create()\n        if with_recipe is not None:\n            repo = recipe_kwargs.get('repo', {})\n            repo['url'] = repo.get('url', r.url)\n            repo['repo_separator'] = repo.get('repo_separator', self.namespace_validator.repo_separator)\n            recipe_kwargs['repo'] = repo\n            recipe = Recipe.load(\n                with_recipe,\n                name=repo['repo_separator'].join(self.namespace_validator.to_parts(r.name)),\n                **recipe_kwargs\n            )\n            created = recipe.create(\n                base_path=r.local_dir.parent,\n                override_path=self.namespace_validator.to_parts(r.name)[-1]\n            )\n            r.commit('Initial commit', hooks=False)\n            r.push()\n            r.install(codebase=self, deps=True)\n            return created\n\n    def delete_repo(self, name):\n        \"\"\"Delete a repo from the codebase.\"\"\"\n        repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(name))\n        r = Repo(\n            name=name,\n            local_dir=repo_dir,\n            namespace_validation_repo=self.namespace_validation_repo,\n            validation_level=self.settings.validation_level,\n            provider_client=self.settings.provider_settings.repo_client)\n        r.delete()\n\n    def create_namespace_repo(\n            self,\n            name: str | None = None,\n            *,\n            namespace_options: NamespaceOptionsType | NamespaceValidator,\n            delimiters: List[str] | None = None,\n            repo_separator: str | None = None,\n            namespaces_filename: str | Path = 'namespaces.yaml'):\n        \"\"\"Create and populate the validator repo.\"\"\"\n        if name is None:\n            name = self.namespaces_dir.name\n        self.namespace_validation_repo = NamespaceValidationRepo(\n            name=name,\n            namespaces_filename=namespaces_filename,\n            local_dir=self.namespaces_dir\n        )\n        self.namespace_validation_repo.create(\n            namespace_options=namespace_options,\n            delimiters=delimiters,\n            repo_separator=repo_separator\n        )\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.namespace_validator","title":"<code>namespace_validator</code>  <code>property</code>","text":"<p>Get the namespace validator object.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.clone","title":"<code>clone()</code>","text":"<p>Clone all repos that match the codebase to a local (nested) directory.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def clone(self):\n    \"\"\"Clone all repos that match the codebase to a local (nested) directory.\"\"\"\n    # List repos\n    root = self.root_dir\n    root.mkdir(exist_ok=True, parents=True)\n    repos = self.list_repos()\n    # Create folder structure based on namespacing\n    cloned = []\n    for repo in repos:\n        repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(repo))\n        r = Repo(\n            name=repo,\n            local_dir=repo_dir,\n            namespace_validation_repo=self.namespace_validation_repo,\n            validation_level=self.settings.validation_level,\n            provider_client=self.settings.provider_settings.repo_client)\n        if not r.exists_locally:\n            r.clone()\n        r.install(codebase=self, deps=False)\n        cloned.append(r)\n    # Once installed all with no deps, install deps again\n    for repo in cloned:\n        repo.install(codebase=self, deps=True)\n    return cloned\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.create_namespace_repo","title":"<code>create_namespace_repo(name=None, *, namespace_options, delimiters=None, repo_separator=None, namespaces_filename='namespaces.yaml')</code>","text":"<p>Create and populate the validator repo.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def create_namespace_repo(\n        self,\n        name: str | None = None,\n        *,\n        namespace_options: NamespaceOptionsType | NamespaceValidator,\n        delimiters: List[str] | None = None,\n        repo_separator: str | None = None,\n        namespaces_filename: str | Path = 'namespaces.yaml'):\n    \"\"\"Create and populate the validator repo.\"\"\"\n    if name is None:\n        name = self.namespaces_dir.name\n    self.namespace_validation_repo = NamespaceValidationRepo(\n        name=name,\n        namespaces_filename=namespaces_filename,\n        local_dir=self.namespaces_dir\n    )\n    self.namespace_validation_repo.create(\n        namespace_options=namespace_options,\n        delimiters=delimiters,\n        repo_separator=repo_separator\n    )\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.create_repo","title":"<code>create_repo(name, with_recipe=None, **recipe_kwargs)</code>","text":"<p>Create a repo in the codebase.</p> <p>with_recipe will instantiate it with a specific recipe - the kwargs need to be provided to the call.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def create_repo(self, name, with_recipe: Optional[str] = None, **recipe_kwargs):\n    \"\"\"Create a repo in the codebase.\n\n    with_recipe will instantiate it with a specific recipe - the kwargs need to be provided to the call.\n    \"\"\"\n    repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(name))\n    r = Repo(\n        name=name,\n        local_dir=repo_dir,\n        namespace_validation_repo=self.namespace_validation_repo,\n        validation_level=self.settings.validation_level,\n        provider_client=self.settings.provider_settings.repo_client)\n    if r.exists or r.exists_locally:\n        raise ValueError(f'Repo {name} already exists')\n    r.create()\n    if with_recipe is not None:\n        repo = recipe_kwargs.get('repo', {})\n        repo['url'] = repo.get('url', r.url)\n        repo['repo_separator'] = repo.get('repo_separator', self.namespace_validator.repo_separator)\n        recipe_kwargs['repo'] = repo\n        recipe = Recipe.load(\n            with_recipe,\n            name=repo['repo_separator'].join(self.namespace_validator.to_parts(r.name)),\n            **recipe_kwargs\n        )\n        created = recipe.create(\n            base_path=r.local_dir.parent,\n            override_path=self.namespace_validator.to_parts(r.name)[-1]\n        )\n        r.commit('Initial commit', hooks=False)\n        r.push()\n        r.install(codebase=self, deps=True)\n        return created\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.delete_repo","title":"<code>delete_repo(name)</code>","text":"<p>Delete a repo from the codebase.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def delete_repo(self, name):\n    \"\"\"Delete a repo from the codebase.\"\"\"\n    repo_dir = self.root_dir/Path(*self.namespace_validator.to_parts(name))\n    r = Repo(\n        name=name,\n        local_dir=repo_dir,\n        namespace_validation_repo=self.namespace_validation_repo,\n        validation_level=self.settings.validation_level,\n        provider_client=self.settings.provider_settings.repo_client)\n    r.delete()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.list_repos","title":"<code>list_repos()</code>","text":"<p>Get the repo names that are validated by the namespace_validator if provided.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def list_repos(self):\n    \"\"\"Get the repo names that are validated by the namespace_validator if provided.\"\"\"\n    potential_repos = self.settings.provider_settings.repo_client.list()\n    sdk_repos = []\n    for repo in potential_repos:\n        result, _ = self.namespace_validator.validate_name(repo)\n        if result:\n            sdk_repos.append(repo)\n    return sdk_repos\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Codebase.model_post_init","title":"<code>model_post_init(*args, **kwargs)</code>","text":"<p>Set the settings namespace validation repo to the same as the codebase.</p> Source code in <code>nskit/vcs/codebase.py</code> <pre><code>def model_post_init(self, *args, **kwargs):\n    \"\"\"Set the settings namespace validation repo to the same as the codebase.\"\"\"\n    super().model_post_init(*args, **kwargs)\n    self.settings.namespace_validation_repo = self.namespace_validation_repo\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.Repo","title":"<code>Repo</code>","text":"<p>             Bases: <code>_Repo</code></p> <p>Repo with namespace validator.</p> Source code in <code>nskit/vcs/repo.py</code> <pre><code>class Repo(_Repo):\n    \"\"\"Repo with namespace validator.\"\"\"\n\n    namespace_validation_repo: Optional[NamespaceValidationRepo] = None\n    validation_level: ValidationEnum = ValidationEnum.none\n    name: str\n\n    @model_validator(mode='after')\n    def _validate_name(self):\n        value = self.name\n        if self.namespace_validation_repo and self.validation_level in [ValidationEnum.strict, ValidationEnum.warn]:\n            namespace_validator = self.namespace_validation_repo.validator\n            result, message = namespace_validator.validate_name(value)\n            if not result:\n                message = (f'{value} {message.format(key=\"&lt;root&gt;\")}')\n            value = namespace_validator.to_repo_name(value)\n            if self.validation_level == ValidationEnum.strict and not result:\n                raise ValueError(message)\n            elif not result:\n                warnings.warn(message, stacklevel=2)\n        self.name = value\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.NamespaceValidator","title":"<code>NamespaceValidator</code>","text":"<p>             Bases: <code>BaseConfiguration</code></p> <p>Namespace Validator object.</p> Source code in <code>nskit/vcs/namespace_validator.py</code> <pre><code>class NamespaceValidator(BaseConfiguration):\n    \"\"\"Namespace Validator object.\"\"\"\n    options: Optional[NamespaceOptionsType]\n    repo_separator: str = REPO_SEPARATOR\n    delimiters: List[str] = _DELIMITERS\n\n    __delimiters_regexp = None\n    # Validate delimiters to add repo_separator\n\n    @field_validator('delimiters', mode='after')\n    @classmethod\n    def _validate_repo_separator_in_delimiters(cls, v: List[str], info: ValidationInfo):\n        if info.data['repo_separator'] not in v:\n            v.append(info.data['repo_separator'])\n        return v\n\n    @property\n    def _delimiters_regexp(self):\n        if self.__delimiters_regexp is None:\n            self.__delimiters_regexp = '|'.join(map(re.escape, self.delimiters))\n        return self.__delimiters_regexp\n\n    def to_parts(self, name: str):\n        \"\"\"Break the name into the namespace parts.\"\"\"\n        if self.options:\n            return re.split(self._delimiters_regexp, name)\n        return [name]\n\n    def to_repo_name(self, name: str):\n        \"\"\"Convert the name to the appropriate name with a given repo separator.\"\"\"\n        return self.repo_separator.join(self.to_parts(name))\n\n    def validate_name(self, proposed_name: str):\n        \"\"\"Validate a proposed name.\"\"\"\n        name_parts = self.to_parts(proposed_name)\n        if self.options:\n            result, message = self._validate_level(name_parts, self.options)\n            message = message.format(key='&lt;root&gt;')\n        else:\n            result = True\n            message = 'no constraints set'\n        return result, message\n\n    def _validate_level(\n            self,\n            name_parts: List[str],\n            partial_namespace: List[Union[str, Dict]]):\n        not_matched = []\n        for key in partial_namespace:\n            # If it is a dict, then there are mappings of &lt;section&gt;: [&lt;subsection 1&gt;, &lt;subsection 2&gt;]\n            if isinstance(key, dict):\n                for sub_key, new_partial_namespace in key.items():\n                    if sub_key == name_parts[0]:\n                        # This maps to a section with subsections, so we need to validate those\n                        result, message = self._validate_level(name_parts[1:], new_partial_namespace)\n                        if not result:\n                            message = message.format(key=sub_key)\n                        return result, message\n                    not_matched.append(sub_key)\n            # Otherwise it is a string\n            elif key == name_parts[0]:\n                return True, 'ok'\n            else:\n                not_matched.append(key)\n        return False, f'Does not match valid names for {{key}}: {\", \".join(not_matched)}, with delimiters: {self.delimiters}'\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.NamespaceValidator.to_parts","title":"<code>to_parts(name)</code>","text":"<p>Break the name into the namespace parts.</p> Source code in <code>nskit/vcs/namespace_validator.py</code> <pre><code>def to_parts(self, name: str):\n    \"\"\"Break the name into the namespace parts.\"\"\"\n    if self.options:\n        return re.split(self._delimiters_regexp, name)\n    return [name]\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.NamespaceValidator.to_repo_name","title":"<code>to_repo_name(name)</code>","text":"<p>Convert the name to the appropriate name with a given repo separator.</p> Source code in <code>nskit/vcs/namespace_validator.py</code> <pre><code>def to_repo_name(self, name: str):\n    \"\"\"Convert the name to the appropriate name with a given repo separator.\"\"\"\n    return self.repo_separator.join(self.to_parts(name))\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.NamespaceValidator.validate_name","title":"<code>validate_name(proposed_name)</code>","text":"<p>Validate a proposed name.</p> Source code in <code>nskit/vcs/namespace_validator.py</code> <pre><code>def validate_name(self, proposed_name: str):\n    \"\"\"Validate a proposed name.\"\"\"\n    name_parts = self.to_parts(proposed_name)\n    if self.options:\n        result, message = self._validate_level(name_parts, self.options)\n        message = message.format(key='&lt;root&gt;')\n    else:\n        result = True\n        message = 'no constraints set'\n    return result, message\n</code></pre>"},{"location":"api/nskit.vcs/#installers","title":"Installers","text":"<p>Repository installers.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.Installer","title":"<code>Installer</code>","text":"<p>             Bases: <code>ABC</code>, <code>BaseConfiguration</code></p> <p>Abstract class for language installer.</p> <p>Can be enabled or disabled using the boolean flag and environment variables.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>class Installer(ABC, BaseConfiguration):\n    \"\"\"Abstract class for language installer.\n\n    Can be enabled or disabled using the boolean flag and environment variables.\n    \"\"\"\n\n    enabled: bool = True\n\n    def check(self, path: Path, **kwargs):\n        \"\"\"Check if the installer is enabled, and the repo matches the criteria.\"\"\"\n        return self.enabled and self.check_repo(path=path, **kwargs)\n\n    @abstractmethod\n    def check_repo(self, path: Path, **kwargs):\n        \"\"\"Check if the repo matches the installer language.\"\"\"\n        raise NotImplementedError('Implement in a language specific installer. It should check for appropriate files to signal that it is a repo of that type')\n\n    @abstractmethod\n    def install(self, path: Path, *, codebase: Codebase | None = None, deps: bool = True, **kwargs):\n        \"\"\"Install the repo into the appropriate environment.\"\"\"\n        raise NotImplementedError('Implement in language specific installer. It should take in any language specific environment/executables')\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.Installer.check","title":"<code>check(path, **kwargs)</code>","text":"<p>Check if the installer is enabled, and the repo matches the criteria.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>def check(self, path: Path, **kwargs):\n    \"\"\"Check if the installer is enabled, and the repo matches the criteria.\"\"\"\n    return self.enabled and self.check_repo(path=path, **kwargs)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.Installer.check_repo","title":"<code>check_repo(path, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Check if the repo matches the installer language.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>@abstractmethod\ndef check_repo(self, path: Path, **kwargs):\n    \"\"\"Check if the repo matches the installer language.\"\"\"\n    raise NotImplementedError('Implement in a language specific installer. It should check for appropriate files to signal that it is a repo of that type')\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.Installer.install","title":"<code>install(path, *, codebase=None, deps=True, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Install the repo into the appropriate environment.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>@abstractmethod\ndef install(self, path: Path, *, codebase: Codebase | None = None, deps: bool = True, **kwargs):\n    \"\"\"Install the repo into the appropriate environment.\"\"\"\n    raise NotImplementedError('Implement in language specific installer. It should take in any language specific environment/executables')\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.PythonInstaller","title":"<code>PythonInstaller</code>","text":"<p>             Bases: <code>Installer</code></p> <p>Python language installer.</p> <p>Can be enabled or disabled using the boolean flag and environment variables. The virtualenv config can be updated (to a custom dir/path relative to the codebase root)</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>class PythonInstaller(Installer):\n    \"\"\"Python language installer.\n\n    Can be enabled or disabled using the boolean flag and environment variables. The virtualenv config can be updated (to a custom dir/path relative to the codebase root)\n    \"\"\"\n\n    model_config = SettingsConfigDict(env_prefix='NSKIT_PYTHON_INSTALLER_', env_file='.env')\n    virtualenv_dir: Path = Path('.venv')\n    # Include Azure DevOps seeder\n    virtualenv_args: List[str] = []\n    # For Azure Devops could set this to something like: ['--seeder', 'azdo-pip']\n\n    def check_repo(self, path: Path):\n        \"\"\"Check if this is a python repo.\"\"\"\n        logger.debug(f'{self.__class__} enabled, checking for match.')\n        result = (path/'setup.py').exists() or (path/'pyproject.toml').exists() or (path/'requirements.txt').exists()\n        logger.info(f'Matched repo to {self.__class__}.')\n        return result\n\n    def install(self, path: Path, *, codebase: Codebase | None = None, executable: str = 'venv', deps: bool = True):\n        \"\"\"Install the repo.\n\n        executable can override the executable to use (e.g. a virtualenv)\n        deps controls whether dependencies are installed or not.\n        \"\"\"\n        executable = self._get_executable(path, codebase, executable)\n        logger.info(f'Installing using {executable}.')\n        args = []\n        if not deps:\n            args.append('--no-deps')\n        with ChDir(path):\n            if Path('setup.py').exists() or Path('pyproject.toml').exists():\n                subprocess.check_call([str(executable), '-m', 'pip', 'install', '-e', '.[dev]']+args)  # nosec B603, B607\n            elif deps and Path('requirements.txt').exists():\n                subprocess.check_call([str(executable), '-m', 'pip', 'install', '-r', 'requirements.txt'])  # nosec B603, B607\n\n    def _get_virtualenv(self, full_virtualenv_dir: Path):\n        \"\"\"Get the virtualenv executable.\n\n        Create's it if it doesn't exist.\n        \"\"\"\n        if not full_virtualenv_dir.exists():\n            virtualenv.cli_run([str(full_virtualenv_dir)]+self.virtualenv_args)\n        if sys.platform.startswith('win'):\n            executable = full_virtualenv_dir/'Scripts'/'python.exe'\n        else:\n            executable = full_virtualenv_dir/'bin'/'python'\n        return executable.absolute()\n\n    def _get_executable(self, path: Path, codebase: Codebase | None = None, executable: str | None = 'venv'):\n        # Install in the current environment\n        if self.virtualenv_dir.is_absolute():\n            full_virtualenv_dir = self.virtualenv_dir\n        elif codebase:\n            full_virtualenv_dir = codebase.root_dir/self.virtualenv_dir\n        else:\n            full_virtualenv_dir = path/self.virtualenv_dir\n        if executable is None:\n            executable = sys.executable\n        elif executable == 'venv':\n            executable = self._get_virtualenv(full_virtualenv_dir=full_virtualenv_dir)\n        return executable\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.PythonInstaller.check_repo","title":"<code>check_repo(path)</code>","text":"<p>Check if this is a python repo.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>def check_repo(self, path: Path):\n    \"\"\"Check if this is a python repo.\"\"\"\n    logger.debug(f'{self.__class__} enabled, checking for match.')\n    result = (path/'setup.py').exists() or (path/'pyproject.toml').exists() or (path/'requirements.txt').exists()\n    logger.info(f'Matched repo to {self.__class__}.')\n    return result\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.installer.PythonInstaller.install","title":"<code>install(path, *, codebase=None, executable='venv', deps=True)</code>","text":"<p>Install the repo.</p> <p>executable can override the executable to use (e.g. a virtualenv) deps controls whether dependencies are installed or not.</p> Source code in <code>nskit/vcs/installer.py</code> <pre><code>def install(self, path: Path, *, codebase: Codebase | None = None, executable: str = 'venv', deps: bool = True):\n    \"\"\"Install the repo.\n\n    executable can override the executable to use (e.g. a virtualenv)\n    deps controls whether dependencies are installed or not.\n    \"\"\"\n    executable = self._get_executable(path, codebase, executable)\n    logger.info(f'Installing using {executable}.')\n    args = []\n    if not deps:\n        args.append('--no-deps')\n    with ChDir(path):\n        if Path('setup.py').exists() or Path('pyproject.toml').exists():\n            subprocess.check_call([str(executable), '-m', 'pip', 'install', '-e', '.[dev]']+args)  # nosec B603, B607\n        elif deps and Path('requirements.txt').exists():\n            subprocess.check_call([str(executable), '-m', 'pip', 'install', '-r', 'requirements.txt'])  # nosec B603, B607\n</code></pre>"},{"location":"api/nskit.vcs/#providers","title":"Providers","text":"<p>VCS Providers, accessed using entrypoints.</p>"},{"location":"api/nskit.vcs/#abstract-client","title":"Abstract Client","text":"<p>Abstract classes for the provider.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient","title":"<code>RepoClient</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Repo management client.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>class RepoClient(ABC):\n    \"\"\"Repo management client.\"\"\"\n\n    @abstractmethod\n    def create(self, repo_name: str):\n        \"\"\"Create a repo.\"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n        \"\"\"Get the remote url for a repo.\"\"\"\n        raise NotImplementedError()\n\n    def get_clone_url(self, repo_name: str) -&gt; HttpUrl:\n        \"\"\"Get the clone URL.\n\n        This defaults to the remote url unless specifically implemented.\n        \"\"\"\n        return self.get_remote_url(repo_name)\n\n    @abstractmethod\n    def delete(self, repo_name: str):\n        \"\"\"Delete a repo.\"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def check_exists(self, repo_name: str) -&gt; bool:\n        \"\"\"Check if the repo exists on the remote.\"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def list(self) -&gt; List[str]:\n        \"\"\"List all repos on the remote.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.check_exists","title":"<code>check_exists(repo_name)</code>  <code>abstractmethod</code>","text":"<p>Check if the repo exists on the remote.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractmethod\ndef check_exists(self, repo_name: str) -&gt; bool:\n    \"\"\"Check if the repo exists on the remote.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.create","title":"<code>create(repo_name)</code>  <code>abstractmethod</code>","text":"<p>Create a repo.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractmethod\ndef create(self, repo_name: str):\n    \"\"\"Create a repo.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.delete","title":"<code>delete(repo_name)</code>  <code>abstractmethod</code>","text":"<p>Delete a repo.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractmethod\ndef delete(self, repo_name: str):\n    \"\"\"Delete a repo.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.get_clone_url","title":"<code>get_clone_url(repo_name)</code>","text":"<p>Get the clone URL.</p> <p>This defaults to the remote url unless specifically implemented.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>def get_clone_url(self, repo_name: str) -&gt; HttpUrl:\n    \"\"\"Get the clone URL.\n\n    This defaults to the remote url unless specifically implemented.\n    \"\"\"\n    return self.get_remote_url(repo_name)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.get_remote_url","title":"<code>get_remote_url(repo_name)</code>  <code>abstractmethod</code>","text":"<p>Get the remote url for a repo.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractmethod\ndef get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n    \"\"\"Get the remote url for a repo.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.RepoClient.list","title":"<code>list()</code>  <code>abstractmethod</code>","text":"<p>List all repos on the remote.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractmethod\ndef list(self) -&gt; List[str]:\n    \"\"\"List all repos on the remote.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.VCSProviderSettings","title":"<code>VCSProviderSettings</code>","text":"<p>             Bases: <code>ABC</code>, <code>BaseConfiguration</code></p> <p>Settings for VCS Provider.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>class VCSProviderSettings(ABC, BaseConfiguration):\n    \"\"\"Settings for VCS Provider.\"\"\"\n\n    @abstractproperty\n    def repo_client(self) -&gt; RepoClient:\n        \"\"\"Return the instantiated repo client object for the provider.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.abstract.VCSProviderSettings.repo_client","title":"<code>repo_client()</code>","text":"<p>Return the instantiated repo client object for the provider.</p> Source code in <code>nskit/vcs/providers/abstract.py</code> <pre><code>@abstractproperty\ndef repo_client(self) -&gt; RepoClient:\n    \"\"\"Return the instantiated repo client object for the provider.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/nskit.vcs/#azure-devops","title":"Azure Devops","text":"<p>Azure Devops provider using azure-cli to manage it.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient","title":"<code>AzureDevOpsRepoClient</code>","text":"<p>             Bases: <code>RepoClient</code></p> <p>Client for managing Azure DevOps repos using azure-cli.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>class AzureDevOpsRepoClient(RepoClient):\n    \"\"\"Client for managing Azure DevOps repos using azure-cli.\"\"\"\n\n    def __init__(self, config: AzureDevOpsSettings):\n        \"\"\"Initialise the client.\"\"\"\n        self._cli = get_default_cli()\n        self._config = config\n\n    def _invoke(self, command, out_file=None):\n        return self._cli.invoke(command, out_file=out_file)\n\n    def check_exists(self, repo_name: str) -&gt; bool:\n        \"\"\"Check if the repo exists in the project.\"\"\"\n        output = StringIO()\n        return not self._invoke(['repos',\n                                 'show',\n                                 '--organization',\n                                 self._config.organisation_url,\n                                 '--project',\n                                 self._config.project,\n                                 '-r',\n                                 repo_name],\n                                out_file=output)\n\n    def create(self, repo_name: str):\n        \"\"\"Create the repo in the project.\"\"\"\n        output = StringIO()\n        return self._invoke(['repos',\n                             'create',\n                             '--organization',\n                             self._config.organisation_url,\n                             '--project',\n                             self._config.project,\n                             '--name',\n                             repo_name],\n                            out_file=output)\n\n    def delete(self, repo_name: str):\n        \"\"\"Delete the repo if it exists in the project.\"\"\"\n        # We need to get the ID\n        show_output = StringIO()\n        result = self._invoke(['repos',\n                               'show',\n                               '--organization',\n                               self._config.organisation_url,\n                               '--project',\n                               self._config.project,\n                               '-r',\n                               repo_name],\n                              out_file=show_output)\n        if not result:\n            # Exists\n            repo_info = json.loads(show_output.getvalue())\n            repo_id = repo_info['id']\n            output = StringIO()\n            return self._invoke(['repos',\n                                 'delete',\n                                 '--organization',\n                                 self._config.organisation_url,\n                                 '--project',\n                                 self._config.project,\n                                 '--id',\n                                 repo_id],\n                                out_file=output)\n\n    def get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n        \"\"\"Get the remote url for the repo.\"\"\"\n        output = StringIO()\n        result = self._invoke(['repos',\n                               'show',\n                               '--organization',\n                               self._config.organisation_url,\n                               '--project',\n                               self._config.project,\n                               '-r',\n                               repo_name],\n                              out_file=output)\n        if not result:\n            # Exists\n            repo_info = json.loads(output.getvalue())\n            return repo_info['remoteUrl']\n\n    def list(self) -&gt; List[str]:\n        \"\"\"List the repos in the project.\"\"\"\n        output = StringIO()\n        result = self._invoke(['repos',\n                               'list',\n                               '--organization',\n                               self._config.organisation_url,\n                               '--project',\n                               self._config.project],\n                              out_file=output)\n        if not result:\n            # Exists\n            repo_list = [u['name'] for u in json.loads(output.getvalue())]\n            return repo_list\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise the client.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def __init__(self, config: AzureDevOpsSettings):\n    \"\"\"Initialise the client.\"\"\"\n    self._cli = get_default_cli()\n    self._config = config\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.check_exists","title":"<code>check_exists(repo_name)</code>","text":"<p>Check if the repo exists in the project.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def check_exists(self, repo_name: str) -&gt; bool:\n    \"\"\"Check if the repo exists in the project.\"\"\"\n    output = StringIO()\n    return not self._invoke(['repos',\n                             'show',\n                             '--organization',\n                             self._config.organisation_url,\n                             '--project',\n                             self._config.project,\n                             '-r',\n                             repo_name],\n                            out_file=output)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.create","title":"<code>create(repo_name)</code>","text":"<p>Create the repo in the project.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def create(self, repo_name: str):\n    \"\"\"Create the repo in the project.\"\"\"\n    output = StringIO()\n    return self._invoke(['repos',\n                         'create',\n                         '--organization',\n                         self._config.organisation_url,\n                         '--project',\n                         self._config.project,\n                         '--name',\n                         repo_name],\n                        out_file=output)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.delete","title":"<code>delete(repo_name)</code>","text":"<p>Delete the repo if it exists in the project.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def delete(self, repo_name: str):\n    \"\"\"Delete the repo if it exists in the project.\"\"\"\n    # We need to get the ID\n    show_output = StringIO()\n    result = self._invoke(['repos',\n                           'show',\n                           '--organization',\n                           self._config.organisation_url,\n                           '--project',\n                           self._config.project,\n                           '-r',\n                           repo_name],\n                          out_file=show_output)\n    if not result:\n        # Exists\n        repo_info = json.loads(show_output.getvalue())\n        repo_id = repo_info['id']\n        output = StringIO()\n        return self._invoke(['repos',\n                             'delete',\n                             '--organization',\n                             self._config.organisation_url,\n                             '--project',\n                             self._config.project,\n                             '--id',\n                             repo_id],\n                            out_file=output)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.get_remote_url","title":"<code>get_remote_url(repo_name)</code>","text":"<p>Get the remote url for the repo.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n    \"\"\"Get the remote url for the repo.\"\"\"\n    output = StringIO()\n    result = self._invoke(['repos',\n                           'show',\n                           '--organization',\n                           self._config.organisation_url,\n                           '--project',\n                           self._config.project,\n                           '-r',\n                           repo_name],\n                          out_file=output)\n    if not result:\n        # Exists\n        repo_info = json.loads(output.getvalue())\n        return repo_info['remoteUrl']\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsRepoClient.list","title":"<code>list()</code>","text":"<p>List the repos in the project.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>def list(self) -&gt; List[str]:\n    \"\"\"List the repos in the project.\"\"\"\n    output = StringIO()\n    result = self._invoke(['repos',\n                           'list',\n                           '--organization',\n                           self._config.organisation_url,\n                           '--project',\n                           self._config.project],\n                          out_file=output)\n    if not result:\n        # Exists\n        repo_list = [u['name'] for u in json.loads(output.getvalue())]\n        return repo_list\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsSettings","title":"<code>AzureDevOpsSettings</code>","text":"<p>             Bases: <code>VCSProviderSettings</code></p> <p>Azure DevOps settings.</p> Source code in <code>nskit/vcs/providers/azure_devops.py</code> <pre><code>class AzureDevOpsSettings(VCSProviderSettings):\n    \"\"\"Azure DevOps settings.\"\"\"\n    model_config = SettingsConfigDict(env_prefix='AZURE_DEVOPS_', env_file='.env')\n    url: HttpUrl = \"https://dev.azure.com\"\n    organisation: str\n    project: str\n\n    @property\n    def organisation_url(self):\n        \"\"\"Get the organistion Url.\"\"\"\n        return f'{self.url}/{self.organisation}'\n\n    @property\n    def project_url(self):\n        \"\"\"Get the project url.\"\"\"\n        return f'{self.organisation_url}/{self.project}'\n\n    @property\n    def repo_client(self) -&gt; 'AzureDevOpsRepoClient':\n        \"\"\"Get the instantiated repo client.\"\"\"\n        return AzureDevOpsRepoClient(self)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsSettings.organisation_url","title":"<code>organisation_url</code>  <code>property</code>","text":"<p>Get the organistion Url.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsSettings.project_url","title":"<code>project_url</code>  <code>property</code>","text":"<p>Get the project url.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.azure_devops.AzureDevOpsSettings.repo_client","title":"<code>repo_client: AzureDevOpsRepoClient</code>  <code>property</code>","text":"<p>Get the instantiated repo client.</p>"},{"location":"api/nskit.vcs/#github","title":"Github","text":"<p>Github provider using ghapi.</p>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubOrgType","title":"<code>GithubOrgType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Org type, user or org.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>class GithubOrgType(Enum):\n    \"\"\"Org type, user or org.\"\"\"\n    user = 'User'\n    org = 'Org'\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient","title":"<code>GithubRepoClient</code>","text":"<p>             Bases: <code>RepoClient</code></p> <p>Client for managing github repos.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>class GithubRepoClient(RepoClient):\n    \"\"\"Client for managing github repos.\"\"\"\n\n    def __init__(self, config: GithubSettings):\n        \"\"\"Initialise the client.\"\"\"\n        self._config = config\n        self._github = GhApi(token=self._config.token.get_secret_value(), gh_host=str(self._config.url).rstrip('/'))\n        # If the organisation is set, we get it, and assume that the token is valid\n        # Otherwise default to the user\n        if self._config.organisation:\n            try:\n                self._github.orgs.get(self._config.organisation)\n                self._org_type = GithubOrgType.org\n            except HTTP404NotFoundError:\n                self._github.users.get_by_username(self._config.organisation)\n                self._org_type = GithubOrgType.user\n        else:\n            self._config.organisation = self._github.users.get_authenticated()['login']\n            self._org_type = GithubOrgType.user\n\n    def create(self, repo_name: str):\n        \"\"\"Create the repo in the user/organisation.\"\"\"\n        kwargs = {\n            'name': repo_name,\n            'private': self._config.repo.private,\n            'has_issues': self._config.repo.has_issues,\n            'has_wiki': self._config.repo.has_wiki,\n            'has_downloads': self._config.repo.has_downloads,\n            'has_projects': self._config.repo.has_projects,\n            'allow_squash_merge': self._config.repo.allow_squash_merge,\n            'allow_merge_commit': self._config.repo.allow_merge_commit,\n            'allow_rebase_merge': self._config.repo.allow_rebase_merge,\n            'auto_init': self._config.repo.auto_init,\n            'delete_branch_on_merge': self._config.repo.delete_branch_on_merge\n        }\n        if self._org_type == GithubOrgType.org:\n            self._github.repos.create_in_org(self._config.organisation, **kwargs)\n        else:\n            self._github.repos.create_for_authenticated_user(**kwargs)\n\n    def get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n        \"\"\"Get the remote url for the repo.\"\"\"\n        if self.check_exists(repo_name):\n            return self._github.repos.get(self._config.organisation, repo_name)['html_url']\n\n    def get_clone_url(self, repo_name: str) -&gt; HttpUrl:\n        \"\"\"Get the clone url for the repo.\"\"\"\n        if self.check_exists(repo_name):\n            return self._github.repos.get(self._config.organisation, repo_name)['clone_url']\n\n    def delete(self, repo_name: str):\n        \"\"\"Delete the repo if it exists in the organisation/user.\"\"\"\n        if self.check_exists(repo_name):\n            return self._github.repos.delete(self._config.organisation, repo_name)\n\n    def check_exists(self, repo_name: str) -&gt; bool:\n        \"\"\"Check if the repo exists in the organisation/user.\"\"\"\n        try:\n            self._github.repos.get(self._config.organisation, repo_name)\n            return True\n        except HTTP404NotFoundError:\n            return False\n\n    def list(self) -&gt; List[str]:\n        \"\"\"List the repos in the project.\"\"\"\n        repos = []\n        if self._org_type == GithubOrgType.org:\n            get_method = self._github.repos.list_for_org\n        else:\n            get_method = self._github.repos.list_for_user\n        for u in paged(get_method, self._config.organisation, per_page=100):\n            repos += [x['name'] for x in u]\n        return repos\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise the client.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def __init__(self, config: GithubSettings):\n    \"\"\"Initialise the client.\"\"\"\n    self._config = config\n    self._github = GhApi(token=self._config.token.get_secret_value(), gh_host=str(self._config.url).rstrip('/'))\n    # If the organisation is set, we get it, and assume that the token is valid\n    # Otherwise default to the user\n    if self._config.organisation:\n        try:\n            self._github.orgs.get(self._config.organisation)\n            self._org_type = GithubOrgType.org\n        except HTTP404NotFoundError:\n            self._github.users.get_by_username(self._config.organisation)\n            self._org_type = GithubOrgType.user\n    else:\n        self._config.organisation = self._github.users.get_authenticated()['login']\n        self._org_type = GithubOrgType.user\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.check_exists","title":"<code>check_exists(repo_name)</code>","text":"<p>Check if the repo exists in the organisation/user.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def check_exists(self, repo_name: str) -&gt; bool:\n    \"\"\"Check if the repo exists in the organisation/user.\"\"\"\n    try:\n        self._github.repos.get(self._config.organisation, repo_name)\n        return True\n    except HTTP404NotFoundError:\n        return False\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.create","title":"<code>create(repo_name)</code>","text":"<p>Create the repo in the user/organisation.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def create(self, repo_name: str):\n    \"\"\"Create the repo in the user/organisation.\"\"\"\n    kwargs = {\n        'name': repo_name,\n        'private': self._config.repo.private,\n        'has_issues': self._config.repo.has_issues,\n        'has_wiki': self._config.repo.has_wiki,\n        'has_downloads': self._config.repo.has_downloads,\n        'has_projects': self._config.repo.has_projects,\n        'allow_squash_merge': self._config.repo.allow_squash_merge,\n        'allow_merge_commit': self._config.repo.allow_merge_commit,\n        'allow_rebase_merge': self._config.repo.allow_rebase_merge,\n        'auto_init': self._config.repo.auto_init,\n        'delete_branch_on_merge': self._config.repo.delete_branch_on_merge\n    }\n    if self._org_type == GithubOrgType.org:\n        self._github.repos.create_in_org(self._config.organisation, **kwargs)\n    else:\n        self._github.repos.create_for_authenticated_user(**kwargs)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.delete","title":"<code>delete(repo_name)</code>","text":"<p>Delete the repo if it exists in the organisation/user.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def delete(self, repo_name: str):\n    \"\"\"Delete the repo if it exists in the organisation/user.\"\"\"\n    if self.check_exists(repo_name):\n        return self._github.repos.delete(self._config.organisation, repo_name)\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.get_clone_url","title":"<code>get_clone_url(repo_name)</code>","text":"<p>Get the clone url for the repo.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def get_clone_url(self, repo_name: str) -&gt; HttpUrl:\n    \"\"\"Get the clone url for the repo.\"\"\"\n    if self.check_exists(repo_name):\n        return self._github.repos.get(self._config.organisation, repo_name)['clone_url']\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.get_remote_url","title":"<code>get_remote_url(repo_name)</code>","text":"<p>Get the remote url for the repo.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def get_remote_url(self, repo_name: str) -&gt; HttpUrl:\n    \"\"\"Get the remote url for the repo.\"\"\"\n    if self.check_exists(repo_name):\n        return self._github.repos.get(self._config.organisation, repo_name)['html_url']\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoClient.list","title":"<code>list()</code>","text":"<p>List the repos in the project.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>def list(self) -&gt; List[str]:\n    \"\"\"List the repos in the project.\"\"\"\n    repos = []\n    if self._org_type == GithubOrgType.org:\n        get_method = self._github.repos.list_for_org\n    else:\n        get_method = self._github.repos.list_for_user\n    for u in paged(get_method, self._config.organisation, per_page=100):\n        repos += [x['name'] for x in u]\n    return repos\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubRepoSettings","title":"<code>GithubRepoSettings</code>","text":"<p>             Bases: <code>BaseConfiguration</code></p> <p>Github Repo settings.</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>class GithubRepoSettings(BaseConfiguration):\n    \"\"\"Github Repo settings.\"\"\"\n    private: bool = True\n    has_issues: Optional[bool] = None\n    has_wiki: Optional[bool] = None\n    has_downloads: Optional[bool] = None\n    has_projects: Optional[bool] = None\n    allow_squash_merge: Optional[bool] = None\n    allow_merge_commit: Optional[bool] = None\n    allow_rebase_merge: Optional[bool] = None\n    delete_branch_on_merge: Optional[bool] = None\n    auto_init: bool = False\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubSettings","title":"<code>GithubSettings</code>","text":"<p>             Bases: <code>VCSProviderSettings</code></p> <p>Github settings.</p> <p>Uses PAT token for auth (set in environment variables as GITHUB_TOKEN)</p> Source code in <code>nskit/vcs/providers/github.py</code> <pre><code>class GithubSettings(VCSProviderSettings):\n    \"\"\"Github settings.\n\n    Uses PAT token for auth (set in environment variables as GITHUB_TOKEN)\n    \"\"\"\n    model_config = SettingsConfigDict(env_prefix='GITHUB_', env_file='.env')\n    interactive: bool = Field(False, description='Use Interactive Validation for token')\n    url: HttpUrl = \"https://api.github.com\"\n    organisation: Optional[str] = Field(None, description='Organisation to work in, otherwise uses the user for the token')\n    token: SecretStr = Field(None, validate_default=True, description='Token to use for authentication, falls back to interactive device authentication if not provided')\n    repo: GithubRepoSettings = GithubRepoSettings()\n\n    @property\n    def repo_client(self) -&gt; 'GithubRepoClient':\n        \"\"\"Get the instantiated repo client.\"\"\"\n        return GithubRepoClient(self)\n\n    @field_validator('token', mode='before')\n    @classmethod\n    def _validate_token(cls, value, info: ValidationInfo):\n        if value is None and info.data.get('interactive', False):\n            ghauth = GhDeviceAuth(_def_clientid, Scope.repo, Scope.delete_repo)\n            print(ghauth.url_docs())\n            ghauth.open_browser()\n            value = ghauth.wait()\n        return value\n</code></pre>"},{"location":"api/nskit.vcs/#nskit.vcs.providers.github.GithubSettings.repo_client","title":"<code>repo_client: GithubRepoClient</code>  <code>property</code>","text":"<p>Get the instantiated repo client.</p>"},{"location":"developing/","title":"Contributing to NSKit","text":"<p>We love contributions to NSKit</p>"},{"location":"developing/#issues","title":"Issues","text":"<p>Please raise issues, queries or discussions here.</p>"},{"location":"developing/#contributing-to-the-codebase","title":"Contributing to the codebase","text":""},{"location":"developing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on Github, and clone your fork to your local machine.</p> <p>Make sure you have the prerequisites installed (for adding code): * Python (Versions from 3.8) * virtualenv or another virtual environment tool * git</p> <p>Create and activate a virtual environment.</p> <p>Install <code>nskit</code>:</p> <pre><code># Install nskit as an editable install with the dev dependencies\npip install -e \".[dev]\"\n</code></pre> <p>The codebase uses <code>pre-commit</code>, so please use <code>pre-commit install</code> and <code>pre-commit install-hooks</code> to make sure the pre-commit hooks are installed correctly.</p>"},{"location":"developing/#checkout-a-branch-and-make-changes","title":"Checkout a branch and make changes","text":"<p>Create a branch to make  your changes in: <pre><code># Checkout a new branch and make your changes\ngit checkout -b my-branch\n# Make your changes...\n</code></pre></p>"},{"location":"developing/#run-tests-and-linting","title":"Run tests and linting","text":"<p><code>nskit</code> uses <code>nox</code> for running tests. <pre><code># You can either use session tags with the -s flag\nnox -s test lint\n# There are also sessions: security, types, pre-commit\n\n# or the -t lint and test tags\nnox -t lint\n# This includes lint, pre-commit, security (bandit and pipenv check), types\n\nnox -t test\n</code></pre></p>"},{"location":"developing/#build-docs","title":"Build docs","text":"<p>If you have edited the docs (or signatures/classes), please check the docs: <pre><code>nox -t docs\n</code></pre></p> <p>They will be output to <code>build/docs</code></p>"},{"location":"developing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Commit your changes, push your branch to GitHub, and create a pull request to the main nskit repo, and please include clear information in the pull request for review.</p>"},{"location":"developing/license/","title":"License","text":"<p><code>nskit</code> is licensed under the MIT License. <pre><code>Copyright (c) 2020-202x The nskit developers\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre></p>"},{"location":"developing/sbom/","title":"Software Bill of Materials","text":"<p><code>nskit</code> is licensed under the MIT License.</p> <p>The dependencies for <code>nskit</code> are:</p>"},{"location":"developing/sbom/#runtime-dependencies","title":"Runtime Dependencies","text":"<p>These are the dependencies used for running <code>nskit</code>:</p>"},{"location":"developing/sbom/#gitpython","title":"GitPython","text":"<p><code>BSD LICENSE</code> Version Checked: 3.1.40 Author: Sebastian Thiel, Michael Trier </p>"},{"location":"developing/sbom/#jinja2","title":"Jinja2","text":"<p><code>BSD LICENSE</code> Version Checked: 3.1.2 Author: Armin Ronacher </p>"},{"location":"developing/sbom/#markupsafe","title":"MarkupSafe","text":"<p><code>BSD LICENSE</code> Version Checked: 2.1.3 Author: UNKNOWN </p>"},{"location":"developing/sbom/#aenum","title":"aenum","text":"<p><code>BSD LICENSE</code> Version Checked: 3.1.15 Author: Ethan Furman </p>"},{"location":"developing/sbom/#annotated-types","title":"annotated-types","text":"<p><code>MIT LICENSE</code> Version Checked: 0.6.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#backportsentry-points-selectable","title":"backports.entry-points-selectable","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.0 Author: Jason R. Coombs </p>"},{"location":"developing/sbom/#colorama","title":"colorama","text":"<p><code>BSD LICENSE</code> Version Checked: 0.4.6 Author: UNKNOWN </p>"},{"location":"developing/sbom/#distlib","title":"distlib","text":"<p><code>PYTHON SOFTWARE FOUNDATION LICENSE</code> Version Checked: 0.3.8 Author: Vinay Sajip </p>"},{"location":"developing/sbom/#email-validator","title":"email-validator","text":"<p><code>CC0 1.0 UNIVERSAL (CC0 1.0) PUBLIC DOMAIN DEDICATION</code> Version Checked: 2.1.0.post1 Author: Joshua Tauberer </p>"},{"location":"developing/sbom/#fastcore","title":"fastcore","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.5.29 Author: Jeremy Howard and Sylvain Gugger </p>"},{"location":"developing/sbom/#filelock","title":"filelock","text":"<p><code>THE UNLICENSE (UNLICENSE)</code> Version Checked: 3.13.1 Author: UNKNOWN </p>"},{"location":"developing/sbom/#ghapi","title":"ghapi","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.0.4 Author: Jeremy Howard </p>"},{"location":"developing/sbom/#gitdb","title":"gitdb","text":"<p><code>BSD LICENSE</code> Version Checked: 4.0.11 Author: Sebastian Thiel </p>"},{"location":"developing/sbom/#importlib-metadata","title":"importlib-metadata","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 7.0.0 Author: Jason R. Coombs </p>"},{"location":"developing/sbom/#importlib-resources","title":"importlib-resources","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 6.1.1 Author: Barry Warsaw </p>"},{"location":"developing/sbom/#logzero","title":"logzero","text":"<p><code>MIT LICENSE</code> Version Checked: 1.7.0 Author: Chris Hager </p>"},{"location":"developing/sbom/#orjson","title":"orjson","text":"<p><code>APACHE SOFTWARE LICENSE</code> <code>MIT LICENSE</code> Version Checked: 3.9.10 Author: ijl ijl@mailbox.org </p>"},{"location":"developing/sbom/#packaging","title":"packaging","text":"<p><code>APACHE SOFTWARE LICENSE</code> <code>BSD LICENSE</code> Version Checked: 23.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pip","title":"pip","text":"<p><code>MIT LICENSE</code> Version Checked: 23.3.1 Author: The pip developers </p>"},{"location":"developing/sbom/#platformdirs","title":"platformdirs","text":"<p><code>MIT LICENSE</code> Version Checked: 4.1.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pydantic","title":"pydantic","text":"<p><code>MIT LICENSE</code> Version Checked: 2.5.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pydantic-settings","title":"pydantic-settings","text":"<p><code>MIT LICENSE</code> Version Checked: 2.1.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pydantic_core","title":"pydantic_core","text":"<p><code>MIT LICENSE</code> Version Checked: 2.14.5 Author: UNKNOWN </p>"},{"location":"developing/sbom/#python-dotenv","title":"python-dotenv","text":"<p><code>BSD LICENSE</code> Version Checked: 1.0.0 Author: Saurabh Kumar </p>"},{"location":"developing/sbom/#ruamelyaml","title":"ruamel.yaml","text":"<p><code>MIT LICENSE</code> Version Checked: 0.18.5 Author: Anthon van der Neut </p>"},{"location":"developing/sbom/#ruamelyamlclib","title":"ruamel.yaml.clib","text":"<p><code>MIT LICENSE</code> Version Checked: 0.2.8 Author: Anthon van der Neut </p>"},{"location":"developing/sbom/#tomlkit","title":"tomlkit","text":"<p><code>MIT LICENSE</code> Version Checked: 0.12.3 Author: S\u00e9bastien Eustace </p>"},{"location":"developing/sbom/#typing_extensions","title":"typing_extensions","text":"<p><code>PYTHON SOFTWARE FOUNDATION LICENSE</code> Version Checked: 4.9.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#virtualenv","title":"virtualenv","text":"<p><code>MIT LICENSE</code> Version Checked: 20.25.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#zipp","title":"zipp","text":"<p><code>MIT LICENSE</code> Version Checked: 3.17.0 Author: Jason R. Coombs</p>"},{"location":"developing/sbom/#extras","title":"Extras:","text":""},{"location":"developing/sbom/#github","title":"Github","text":""},{"location":"developing/sbom/#azure-devops","title":"Azure Devops","text":""},{"location":"developing/sbom/#pygithub","title":"PyGithub","text":"<p><code>GNU LIBRARY OR LESSER GENERAL PUBLIC LICENSE (LGPL)</code> Version Checked: 2.1.1 Author: Vincent Jacques </p>"},{"location":"developing/sbom/#pynacl","title":"PyNaCl","text":"<p><code>APACHE LICENSE 2.0</code> Version Checked: 1.5.0 Author: The PyNaCl developers </p>"},{"location":"developing/sbom/#antlr4-python3-runtime","title":"antlr4-python3-runtime","text":"<p><code>BSD</code> Version Checked: 4.13.1 Author: Terence Parr, Sam Harwell </p>"},{"location":"developing/sbom/#azure-appconfiguration","title":"azure-appconfiguration","text":"<p><code>MIT LICENSE</code> Version Checked: 1.5.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-batch","title":"azure-batch","text":"<p><code>MIT LICENSE</code> Version Checked: 14.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-cli","title":"azure-cli","text":"<p><code>MIT LICENSE</code> Version Checked: 2.55.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-cli-core","title":"azure-cli-core","text":"<p><code>MIT LICENSE</code> Version Checked: 2.55.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-cosmos","title":"azure-cosmos","text":"<p><code>MIT LICENSE</code> Version Checked: 4.5.1 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-data-tables","title":"azure-data-tables","text":"<p><code>MIT LICENSE</code> Version Checked: 12.4.4 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-datalake-store","title":"azure-datalake-store","text":"<p><code>MIT LICENSE</code> Version Checked: 0.0.53 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-devops-artifacts-helpers","title":"azure-devops-artifacts-helpers","text":"<p><code>MIT LICENSE</code> Version Checked: 1.2.0 Author: David Pugh </p>"},{"location":"developing/sbom/#azure-graphrbac","title":"azure-graphrbac","text":"<p><code>MIT LICENSE</code> Version Checked: 0.61.1 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-keyvault-administration","title":"azure-keyvault-administration","text":"<p><code>MIT LICENSE</code> Version Checked: 4.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-keyvault-certificates","title":"azure-keyvault-certificates","text":"<p><code>MIT LICENSE</code> Version Checked: 4.7.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-keyvault-keys","title":"azure-keyvault-keys","text":"<p><code>MIT LICENSE</code> Version Checked: 4.8.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-keyvault-secrets","title":"azure-keyvault-secrets","text":"<p><code>MIT LICENSE</code> Version Checked: 4.7.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-loganalytics","title":"azure-loganalytics","text":"<p><code>MIT LICENSE</code> Version Checked: 0.1.1 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-advisor","title":"azure-mgmt-advisor","text":"<p><code>MIT LICENSE</code> Version Checked: 9.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-apimanagement","title":"azure-mgmt-apimanagement","text":"<p><code>MIT LICENSE</code> Version Checked: 4.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-appconfiguration","title":"azure-mgmt-appconfiguration","text":"<p><code>MIT LICENSE</code> Version Checked: 3.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-appcontainers","title":"azure-mgmt-appcontainers","text":"<p><code>MIT LICENSE</code> Version Checked: 3.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-applicationinsights","title":"azure-mgmt-applicationinsights","text":"<p><code>MIT LICENSE</code> Version Checked: 4.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-authorization","title":"azure-mgmt-authorization","text":"<p><code>MIT LICENSE</code> Version Checked: 4.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-batch","title":"azure-mgmt-batch","text":"<p><code>MIT LICENSE</code> Version Checked: 17.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-batchai","title":"azure-mgmt-batchai","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-billing","title":"azure-mgmt-billing","text":"<p><code>MIT LICENSE</code> Version Checked: 6.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-botservice","title":"azure-mgmt-botservice","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-cdn","title":"azure-mgmt-cdn","text":"<p><code>MIT LICENSE</code> Version Checked: 13.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-cognitiveservices","title":"azure-mgmt-cognitiveservices","text":"<p><code>MIT LICENSE</code> Version Checked: 13.5.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-compute","title":"azure-mgmt-compute","text":"<p><code>MIT LICENSE</code> Version Checked: 30.4.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-containerinstance","title":"azure-mgmt-containerinstance","text":"<p><code>MIT LICENSE</code> Version Checked: 10.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-containerregistry","title":"azure-mgmt-containerregistry","text":"<p><code>MIT LICENSE</code> Version Checked: 10.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-containerservice","title":"azure-mgmt-containerservice","text":"<p><code>MIT LICENSE</code> Version Checked: 28.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-cosmosdb","title":"azure-mgmt-cosmosdb","text":"<p><code>MIT LICENSE</code> Version Checked: 9.4.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-databoxedge","title":"azure-mgmt-databoxedge","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-datalake-store","title":"azure-mgmt-datalake-store","text":"<p><code>MIT LICENSE</code> Version Checked: 0.5.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-datamigration","title":"azure-mgmt-datamigration","text":"<p><code>MIT LICENSE</code> Version Checked: 10.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-devtestlabs","title":"azure-mgmt-devtestlabs","text":"<p><code>MIT LICENSE</code> Version Checked: 9.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-dns","title":"azure-mgmt-dns","text":"<p><code>MIT LICENSE</code> Version Checked: 8.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-eventgrid","title":"azure-mgmt-eventgrid","text":"<p><code>MIT LICENSE</code> Version Checked: 10.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-eventhub","title":"azure-mgmt-eventhub","text":"<p><code>MIT LICENSE</code> Version Checked: 11.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-extendedlocation","title":"azure-mgmt-extendedlocation","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-hdinsight","title":"azure-mgmt-hdinsight","text":"<p><code>MIT LICENSE</code> Version Checked: 9.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-imagebuilder","title":"azure-mgmt-imagebuilder","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-iotcentral","title":"azure-mgmt-iotcentral","text":"<p><code>MIT LICENSE</code> Version Checked: 9.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-iothub","title":"azure-mgmt-iothub","text":"<p><code>MIT LICENSE</code> Version Checked: 3.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-iothubprovisioningservices","title":"azure-mgmt-iothubprovisioningservices","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-keyvault","title":"azure-mgmt-keyvault","text":"<p><code>MIT LICENSE</code> Version Checked: 10.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-kusto","title":"azure-mgmt-kusto","text":"<p><code>MIT LICENSE</code> Version Checked: 3.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-loganalytics","title":"azure-mgmt-loganalytics","text":"<p><code>MIT LICENSE</code> Version Checked: 12.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-managedservices","title":"azure-mgmt-managedservices","text":"<p><code>MIT LICENSE</code> Version Checked: 6.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-managementgroups","title":"azure-mgmt-managementgroups","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-maps","title":"azure-mgmt-maps","text":"<p><code>MIT LICENSE</code> Version Checked: 2.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-marketplaceordering","title":"azure-mgmt-marketplaceordering","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-media","title":"azure-mgmt-media","text":"<p><code>MIT LICENSE</code> Version Checked: 10.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-monitor","title":"azure-mgmt-monitor","text":"<p><code>MIT LICENSE</code> Version Checked: 6.0.2 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-msi","title":"azure-mgmt-msi","text":"<p><code>MIT LICENSE</code> Version Checked: 7.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-netapp","title":"azure-mgmt-netapp","text":"<p><code>MIT LICENSE</code> Version Checked: 11.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-policyinsights","title":"azure-mgmt-policyinsights","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-privatedns","title":"azure-mgmt-privatedns","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-rdbms","title":"azure-mgmt-rdbms","text":"<p><code>MIT LICENSE</code> Version Checked: 10.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-recoveryservices","title":"azure-mgmt-recoveryservices","text":"<p><code>MIT LICENSE</code> Version Checked: 2.5.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-recoveryservicesbackup","title":"azure-mgmt-recoveryservicesbackup","text":"<p><code>MIT LICENSE</code> Version Checked: 7.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-redhatopenshift","title":"azure-mgmt-redhatopenshift","text":"<p><code>MIT LICENSE</code> Version Checked: 1.4.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-redis","title":"azure-mgmt-redis","text":"<p><code>MIT LICENSE</code> Version Checked: 14.3.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-resource","title":"azure-mgmt-resource","text":"<p><code>MIT LICENSE</code> Version Checked: 23.0.1 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-search","title":"azure-mgmt-search","text":"<p><code>MIT LICENSE</code> Version Checked: 9.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-security","title":"azure-mgmt-security","text":"<p><code>MIT LICENSE</code> Version Checked: 5.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-servicebus","title":"azure-mgmt-servicebus","text":"<p><code>MIT LICENSE</code> Version Checked: 8.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-servicefabric","title":"azure-mgmt-servicefabric","text":"<p><code>MIT LICENSE</code> Version Checked: 2.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-servicefabricmanagedclusters","title":"azure-mgmt-servicefabricmanagedclusters","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-servicelinker","title":"azure-mgmt-servicelinker","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-signalr","title":"azure-mgmt-signalr","text":"<p><code>MIT LICENSE</code> Version Checked: 1.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-sql","title":"azure-mgmt-sql","text":"<p><code>MIT LICENSE</code> Version Checked: 3.0.1 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-sqlvirtualmachine","title":"azure-mgmt-sqlvirtualmachine","text":"<p><code>MIT LICENSE</code> Version Checked: 0.5.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-storage","title":"azure-mgmt-storage","text":"<p><code>MIT LICENSE</code> Version Checked: 21.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-synapse","title":"azure-mgmt-synapse","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-trafficmanager","title":"azure-mgmt-trafficmanager","text":"<p><code>MIT LICENSE</code> Version Checked: 1.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-mgmt-web","title":"azure-mgmt-web","text":"<p><code>MIT LICENSE</code> Version Checked: 7.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-multiapi-storage","title":"azure-multiapi-storage","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.2.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-storage-common","title":"azure-storage-common","text":"<p><code>MIT LICENSE</code> Version Checked: 2.1.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-synapse-accesscontrol","title":"azure-synapse-accesscontrol","text":"<p><code>MIT LICENSE</code> Version Checked: 0.7.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-synapse-artifacts","title":"azure-synapse-artifacts","text":"<p><code>MIT LICENSE</code> Version Checked: 0.18.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-synapse-managedprivateendpoints","title":"azure-synapse-managedprivateendpoints","text":"<p><code>MIT LICENSE</code> Version Checked: 0.4.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#azure-synapse-spark","title":"azure-synapse-spark","text":"<p><code>MIT LICENSE</code> Version Checked: 0.7.0 Author: Microsoft Corporation </p>"},{"location":"developing/sbom/#chardet","title":"chardet","text":"<p><code>GNU LESSER GENERAL PUBLIC LICENSE V2 OR LATER (LGPLV2+)</code> Version Checked: 5.2.0 Author: Mark Pilgrim </p>"},{"location":"developing/sbom/#click","title":"click","text":"<p><code>BSD LICENSE</code> Version Checked: 8.1.7 Author: UNKNOWN </p>"},{"location":"developing/sbom/#distro","title":"distro","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.9.0 Author: Nir Cohen </p>"},{"location":"developing/sbom/#fabric","title":"fabric","text":"<p><code>BSD LICENSE</code> Version Checked: 3.2.2 Author: Jeff Forcier </p>"},{"location":"developing/sbom/#javaproperties","title":"javaproperties","text":"<p><code>MIT LICENSE</code> Version Checked: 0.8.1 Author: John Thorvald Wodder II </p>"},{"location":"developing/sbom/#jsondiff","title":"jsondiff","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.0 Author: Zoomer Analytics LLC </p>"},{"location":"developing/sbom/#pluggy","title":"pluggy","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.0 Author: Holger Krekel </p>"},{"location":"developing/sbom/#pycomposefile","title":"pycomposefile","text":"<p><code>MIT</code> Version Checked: 0.0.30 Author: Steven Murawski </p>"},{"location":"developing/sbom/#scp","title":"scp","text":"<p><code>GNU LIBRARY OR LESSER GENERAL PUBLIC LICENSE (LGPL)</code> Version Checked: 0.14.5 Author: James Bardin </p>"},{"location":"developing/sbom/#semver","title":"semver","text":"<p><code>BSD LICENSE</code> Version Checked: 3.0.2 Author: Kostiantyn Rybnikov </p>"},{"location":"developing/sbom/#six","title":"six","text":"<p><code>MIT LICENSE</code> Version Checked: 1.16.0 Author: Benjamin Peterson </p>"},{"location":"developing/sbom/#sshtunnel","title":"sshtunnel","text":"<p><code>MIT LICENSE</code> Version Checked: 0.4.0 Author: Pahaz White </p>"},{"location":"developing/sbom/#urllib3","title":"urllib3","text":"<p><code>MIT LICENSE</code> Version Checked: 2.1.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#websocket-client","title":"websocket-client","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.7.0 Author: liris </p>"},{"location":"developing/sbom/#xmltodict","title":"xmltodict","text":"<p><code>MIT LICENSE</code> Version Checked: 0.13.0 Author: Martin Blech</p>"},{"location":"developing/sbom/#development-dependencies","title":"Development Dependencies","text":"<p>These are dependencies used for development (e.g. testing, linting etc.) of <code>nskit</code>:</p>"},{"location":"developing/sbom/#pyyaml","title":"PyYAML","text":"<p><code>MIT LICENSE</code> Version Checked: 6.0.1 Author: Kirill Simonov </p>"},{"location":"developing/sbom/#argcomplete","title":"argcomplete","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 3.2.1 Author: Andrey Kislyuk </p>"},{"location":"developing/sbom/#cfgv","title":"cfgv","text":"<p><code>MIT LICENSE</code> Version Checked: 3.4.0 Author: Anthony Sottile </p>"},{"location":"developing/sbom/#colorlog","title":"colorlog","text":"<p><code>MIT LICENSE</code> Version Checked: 6.8.0 Author: Sam Clements </p>"},{"location":"developing/sbom/#identify","title":"identify","text":"<p><code>MIT LICENSE</code> Version Checked: 2.5.33 Author: Chris Kuehl </p>"},{"location":"developing/sbom/#nodeenv","title":"nodeenv","text":"<p><code>BSD LICENSE</code> Version Checked: 1.8.0 Author: Eugene Kalinin </p>"},{"location":"developing/sbom/#nox","title":"nox","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 2023.4.22 Author: Alethea Katherine Flowers </p>"},{"location":"developing/sbom/#pre-commit","title":"pre-commit","text":"<p><code>MIT LICENSE</code> Version Checked: 3.6.0 Author: Anthony Sottile </p>"},{"location":"developing/sbom/#setuptools","title":"setuptools","text":"<p><code>MIT LICENSE</code> Version Checked: 69.0.2 Author: Python Packaging Authority </p>"},{"location":"developing/sbom/#setuptools-scm","title":"setuptools-scm","text":"<p><code>MIT LICENSE</code> Version Checked: 8.0.4 Author: UNKNOWN </p>"},{"location":"developing/sbom/#tomli","title":"tomli","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.1 Author: UNKNOWN</p>"},{"location":"developing/sbom/#test-dependencies","title":"Test Dependencies","text":""},{"location":"developing/sbom/#attrs","title":"attrs","text":"<p><code>MIT LICENSE</code> Version Checked: 21.4.0 Author: Hynek Schlawack </p>"},{"location":"developing/sbom/#coverage","title":"coverage","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 7.3.3 Author: Ned Batchelder and 221 others </p>"},{"location":"developing/sbom/#exceptiongroup","title":"exceptiongroup","text":"<p><code>MIT LICENSE</code> Version Checked: 1.2.0 Author:  </p>"},{"location":"developing/sbom/#execnet","title":"execnet","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.2 Author: holger krekel and others </p>"},{"location":"developing/sbom/#iniconfig","title":"iniconfig","text":"<p><code>MIT LICENSE</code> Version Checked: 2.0.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pluggy_1","title":"pluggy","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.0 Author: Holger Krekel </p>"},{"location":"developing/sbom/#pytest","title":"pytest","text":"<p><code>MIT LICENSE</code> Version Checked: 7.4.3 Author: Holger Krekel, Bruno Oliveira, Ronny Pfannschmidt, Floris Bruynooghe, Brianna Laugher, Florian Bruhin and others </p>"},{"location":"developing/sbom/#pytest-cov","title":"pytest-cov","text":"<p><code>MIT LICENSE</code> Version Checked: 4.1.0 Author: Marc Schlaich </p>"},{"location":"developing/sbom/#pytest-subtests","title":"pytest-subtests","text":"<p><code>MIT LICENSE</code> Version Checked: 0.11.0 Author: Bruno Oliveira </p>"},{"location":"developing/sbom/#pytest-xdist","title":"pytest-xdist","text":"<p><code>MIT LICENSE</code> Version Checked: 3.5.0 Author: holger krekel and contributors</p>"},{"location":"developing/sbom/#lint-dependencies","title":"Lint Dependencies","text":""},{"location":"developing/sbom/#flake8-pyproject","title":"Flake8-pyproject","text":"<p><code>MIT LICENSE</code> Version Checked: 1.2.3 Author: John Hennig </p>"},{"location":"developing/sbom/#attrs_1","title":"attrs","text":"<p><code>MIT LICENSE</code> Version Checked: 21.4.0 Author: Hynek Schlawack </p>"},{"location":"developing/sbom/#enum34","title":"enum34","text":"<p><code>BSD LICENSE</code> Version Checked: 1.1.10 Author: Ethan Furman </p>"},{"location":"developing/sbom/#eradicate","title":"eradicate","text":"<p><code>MIT LICENSE</code> Version Checked: 2.3.0 Author: Steven Myint </p>"},{"location":"developing/sbom/#flake8","title":"flake8","text":"<p><code>MIT LICENSE</code> Version Checked: 6.1.0 Author: Tarek Ziade </p>"},{"location":"developing/sbom/#flake8-bugbear","title":"flake8-bugbear","text":"<p><code>MIT LICENSE</code> Version Checked: 23.12.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#flake8-comprehensions","title":"flake8-comprehensions","text":"<p><code>MIT LICENSE</code> Version Checked: 3.14.0 Author: Adam Johnson </p>"},{"location":"developing/sbom/#flake8-docstrings","title":"flake8-docstrings","text":"<p><code>MIT LICENSE</code> Version Checked: 1.7.0 Author: Simon ANDR\u00c9 </p>"},{"location":"developing/sbom/#flake8-eradicate","title":"flake8-eradicate","text":"<p><code>MIT LICENSE</code> Version Checked: 1.5.0 Author: Nikita Sobolev </p>"},{"location":"developing/sbom/#flake8-import-order","title":"flake8-import-order","text":"<p><code>MIT LICENSE</code> <code>GNU LESSER GENERAL PUBLIC LICENSE V3 (LGPLV3)</code> Version Checked: 0.18.2 Author: Alex Stapleton </p>"},{"location":"developing/sbom/#flake8-noqa","title":"flake8-noqa","text":"<p><code>GNU LESSER GENERAL PUBLIC LICENSE V3 OR LATER (LGPLV3+)</code> Version Checked: 1.3.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#flake8-unused-arguments","title":"flake8-unused-arguments","text":"<p><code>MIT LICENSE</code> Version Checked: 0.0.13 Author: Nathan Hoad </p>"},{"location":"developing/sbom/#mccabe","title":"mccabe","text":"<p><code>MIT LICENSE</code> Version Checked: 0.7.0 Author: Tarek Ziade </p>"},{"location":"developing/sbom/#pycodestyle","title":"pycodestyle","text":"<p><code>MIT LICENSE</code> Version Checked: 2.11.1 Author: Johann C. Rocholl </p>"},{"location":"developing/sbom/#pydocstyle","title":"pydocstyle","text":"<p><code>MIT LICENSE</code> Version Checked: 6.3.0 Author: Amir Rachum </p>"},{"location":"developing/sbom/#pyflakes","title":"pyflakes","text":"<p><code>MIT LICENSE</code> Version Checked: 3.1.0 Author: A lot of people</p>"},{"location":"developing/sbom/#security-dependencies","title":"Security Dependencies","text":""},{"location":"developing/sbom/#bandit","title":"bandit","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 1.7.6 Author: PyCQA </p>"},{"location":"developing/sbom/#certifi","title":"certifi","text":"<p><code>MOZILLA PUBLIC LICENSE 2.0 (MPL 2.0)</code> Version Checked: 2023.11.17 Author: Kenneth Reitz </p>"},{"location":"developing/sbom/#pipenv","title":"pipenv","text":"<p><code>MIT LICENSE</code> Version Checked: 2023.11.15 Author:  </p>"},{"location":"developing/sbom/#rich","title":"rich","text":"<p><code>MIT LICENSE</code> Version Checked: 13.7.0 Author: Will McGugan </p>"},{"location":"developing/sbom/#stevedore","title":"stevedore","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 5.1.0 Author: OpenStack</p>"},{"location":"developing/sbom/#docs-dependencies","title":"Docs Dependencies","text":""},{"location":"developing/sbom/#babel","title":"Babel","text":"<p><code>BSD LICENSE</code> Version Checked: 2.14.0 Author: Armin Ronacher </p>"},{"location":"developing/sbom/#markdown","title":"Markdown","text":"<p><code>BSD LICENSE</code> Version Checked: 3.5.1 Author: Manfred Stienstra, Yuri Takhteyev </p>"},{"location":"developing/sbom/#pygments","title":"Pygments","text":"<p><code>BSD LICENSE</code> Version Checked: 2.17.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#click_1","title":"click","text":"<p><code>BSD LICENSE</code> Version Checked: 8.1.7 Author: UNKNOWN </p>"},{"location":"developing/sbom/#ghp-import","title":"ghp-import","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 2.1.0 Author: Paul Joseph Davis </p>"},{"location":"developing/sbom/#licensecheck","title":"licensecheck","text":"<p><code>MIT LICENSE</code> Version Checked: 2023.5.2 Author: FredHappyface </p>"},{"location":"developing/sbom/#mergedeep","title":"mergedeep","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.4 Author: Travis Clarke </p>"},{"location":"developing/sbom/#mike","title":"mike","text":"<p><code>BSD LICENSE</code> Version Checked: 2.0.0 Author: Jim Porter </p>"},{"location":"developing/sbom/#mkdocs","title":"mkdocs","text":"<p><code>BSD LICENSE</code> Version Checked: 1.5.3 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs-autorefs","title":"mkdocs-autorefs","text":"<p><code>ISC LICENSE (ISCL)</code> Version Checked: 0.5.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs-coverage","title":"mkdocs-coverage","text":"<p><code>ISC</code> Version Checked: 1.0.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs-git-authors-plugin","title":"mkdocs-git-authors-plugin","text":"<p><code>MIT LICENSE</code> Version Checked: 0.7.2 Author: Tim Vink </p>"},{"location":"developing/sbom/#mkdocs-git-revision-date-localized-plugin","title":"mkdocs-git-revision-date-localized-plugin","text":"<p><code>MIT LICENSE</code> Version Checked: 1.2.2 Author: Tim Vink </p>"},{"location":"developing/sbom/#mkdocs-include-markdown-plugin","title":"mkdocs-include-markdown-plugin","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 6.0.4 Author: Joe Rickerby </p>"},{"location":"developing/sbom/#mkdocs-material","title":"mkdocs-material","text":"<p><code>MIT LICENSE</code> Version Checked: 9.5.2 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs-material-extensions","title":"mkdocs-material-extensions","text":"<p><code>MIT LICENSE</code> Version Checked: 1.3.1 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs_github_changelog","title":"mkdocs_github_changelog","text":"<p><code>MIT LICENSE</code> Version Checked: 0.1.0.post1.dev3+g90c4adc.d20231227 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocs_licenseinfo","title":"mkdocs_licenseinfo","text":"<p><code>MIT LICENSE</code> Version Checked: 0.0.post1.dev1+g4f68eff.d20231223 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocstrings","title":"mkdocstrings","text":"<p><code>ISC</code> Version Checked: 0.24.0 Author: UNKNOWN </p>"},{"location":"developing/sbom/#mkdocstrings-python","title":"mkdocstrings-python","text":"<p><code>ISC</code> Version Checked: 1.7.5 Author: UNKNOWN </p>"},{"location":"developing/sbom/#paginate","title":"paginate","text":"<p><code>MIT LICENSE</code> Version Checked: 0.5.6 Author: Christoph Haas </p>"},{"location":"developing/sbom/#pathspec","title":"pathspec","text":"<p><code>MOZILLA PUBLIC LICENSE 2.0 (MPL 2.0)</code> Version Checked: 0.12.1 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pymdown-extensions","title":"pymdown-extensions","text":"<p><code>MIT LICENSE</code> Version Checked: 10.5 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pyparsing","title":"pyparsing","text":"<p><code>MIT LICENSE</code> Version Checked: 3.1.1 Author: UNKNOWN </p>"},{"location":"developing/sbom/#python-dateutil","title":"python-dateutil","text":"<p><code>BSD LICENSE</code> <code>APACHE SOFTWARE LICENSE</code> Version Checked: 2.8.2 Author: Gustavo Niemeyer </p>"},{"location":"developing/sbom/#pytz","title":"pytz","text":"<p><code>MIT LICENSE</code> Version Checked: 2023.3.post1 Author: Stuart Bishop </p>"},{"location":"developing/sbom/#pyyaml_env_tag","title":"pyyaml_env_tag","text":"<p><code>MIT LICENSE</code> Version Checked: 0.1 Author: Waylan Limberg </p>"},{"location":"developing/sbom/#regex","title":"regex","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 2023.10.3 Author: Matthew Barnett </p>"},{"location":"developing/sbom/#requests","title":"requests","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 2.31.0 Author: Kenneth Reitz </p>"},{"location":"developing/sbom/#verspec","title":"verspec","text":"<p><code>APACHE SOFTWARE LICENSE</code> <code>BSD LICENSE</code> Version Checked: 0.1.0 Author: Jim Porter </p>"},{"location":"developing/sbom/#watchdog","title":"watchdog","text":"<p><code>APACHE SOFTWARE LICENSE</code> Version Checked: 3.0.0 Author: Yesudeep Mangalapilly </p>"},{"location":"developing/sbom/#wcmatch","title":"wcmatch","text":"<p><code>MIT LICENSE</code> Version Checked: 8.5 Author: UNKNOWN</p>"},{"location":"developing/sbom/#build-dependencies","title":"Build Dependencies","text":""},{"location":"developing/sbom/#build","title":"build","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.3 Author: UNKNOWN </p>"},{"location":"developing/sbom/#pyproject_hooks","title":"pyproject_hooks","text":"<p><code>MIT LICENSE</code> Version Checked: 1.0.0 Author: UNKNOWN</p>"},{"location":"coverage/","title":"Test Coverage","text":""}]}